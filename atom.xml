<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>诸葛说</title>
  
  
  <link href="https://rchardzhu.github.io/atom.xml" rel="self"/>
  
  <link href="https://rchardzhu.github.io/"/>
  <updated>2022-04-24T06:12:03.206Z</updated>
  <id>https://rchardzhu.github.io/</id>
  
  <author>
    <name>Richard Zhu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>量化投资分析工具quantstats使用</title>
    <link href="https://rchardzhu.github.io/2022/04/24/using-quantstats-in-invest/"/>
    <id>https://rchardzhu.github.io/2022/04/24/using-quantstats-in-invest/</id>
    <published>2022-04-24T06:08:59.000Z</published>
    <updated>2022-04-24T06:12:03.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://github.com/ranaroussi/quantstats">quantstats</a> – 衡量策略绩效指标的python lib库，用于投资组合分析。主要由3部分组成：</p><ul><li>quantstats.stats：用于计算多种性能指标，如夏普比率、胜率等</li><li>quantstats.plots：用于性能、下降趋势、月度回报等绩效指标的可视化</li><li>quantstats.reports：用于生成度量报告，可保存为html文件</li></ul><h2 id="安装-amp-使用"><a href="#安装-amp-使用" class="headerlink" title="安装&amp;使用"></a>安装&amp;使用</h2><ul><li>安装：<code>pip install</code> quantstats</li><li>使用方法：</li></ul><ol><li>使用quantstats.stats计算多种性能指标，如夏普比率、胜率等</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> quantstats <span class="keyword">as</span> qs</span><br><span class="line">qs.extend_pandas()</span><br><span class="line">stock = qs.utils.download_returns(<span class="string">&#x27;TSLA&#x27;</span>)</span><br><span class="line">stock</span><br><span class="line">Date</span><br><span class="line"><span class="number">2010</span>-06-<span class="number">29</span>         NaN</span><br><span class="line"><span class="number">2010</span>-06-<span class="number">30</span>   -<span class="number">0.002512</span></span><br><span class="line"><span class="number">2010</span>-07-01   -<span class="number">0.078472</span></span><br><span class="line"><span class="number">2010</span>-07-02   -<span class="number">0.125683</span></span><br><span class="line"><span class="number">2010</span>-07-06   -<span class="number">0.160938</span></span><br><span class="line">                ...   </span><br><span class="line"><span class="number">2022</span>-04-<span class="number">18</span>    <span class="number">0.019584</span></span><br><span class="line"><span class="number">2022</span>-04-<span class="number">19</span>    <span class="number">0.023758</span></span><br><span class="line"><span class="number">2022</span>-04-<span class="number">20</span>   -<span class="number">0.049555</span></span><br><span class="line"><span class="number">2022</span>-04-<span class="number">21</span>    <span class="number">0.032317</span></span><br><span class="line"><span class="number">2022</span>-04-<span class="number">22</span>   -<span class="number">0.003698</span></span><br><span class="line">Name: Close, Length: <span class="number">2976</span>, dtype: float64</span><br><span class="line">qs.stats.sharpe(stock)</span><br><span class="line"><span class="number">1.0828146689088534</span></span><br><span class="line">stock.sharpe()</span><br><span class="line"><span class="number">1.0828146689088534</span></span><br></pre></td></tr></table></figure><p>支持的完整指标：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[f <span class="keyword">for</span> f <span class="keyword">in</span> <span class="built_in">dir</span>(qs.stats) <span class="keyword">if</span> f[<span class="number">0</span>] != <span class="string">&#x27;_&#x27;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;adjusted_sortino&#x27;,</span><br><span class="line"> &#x27;autocorr_penalty&#x27;,</span><br><span class="line"> &#x27;avg_loss&#x27;,</span><br><span class="line"> &#x27;avg_return&#x27;,</span><br><span class="line"> &#x27;avg_win&#x27;,</span><br><span class="line"> &#x27;best&#x27;,</span><br><span class="line"> &#x27;cagr&#x27;,</span><br><span class="line"> &#x27;calmar&#x27;,</span><br><span class="line"> &#x27;common_sense_ratio&#x27;,</span><br><span class="line"> &#x27;comp&#x27;,</span><br><span class="line"> &#x27;compare&#x27;,</span><br><span class="line"> &#x27;compsum&#x27;,</span><br><span class="line"> &#x27;conditional_value_at_risk&#x27;,</span><br><span class="line"> &#x27;consecutive_losses&#x27;,</span><br><span class="line"> &#x27;consecutive_wins&#x27;,</span><br><span class="line"> &#x27;cpc_index&#x27;,</span><br><span class="line"> &#x27;cvar&#x27;,</span><br><span class="line"> &#x27;distribution&#x27;,</span><br><span class="line"> &#x27;drawdown_details&#x27;,</span><br><span class="line"> &#x27;expected_return&#x27;,</span><br><span class="line"> &#x27;expected_shortfall&#x27;,</span><br><span class="line"> &#x27;exposure&#x27;,</span><br><span class="line"> &#x27;gain_to_pain_ratio&#x27;,</span><br><span class="line"> &#x27;geometric_mean&#x27;,</span><br><span class="line"> &#x27;ghpr&#x27;,</span><br><span class="line"> &#x27;greeks&#x27;,</span><br><span class="line"> &#x27;implied_volatility&#x27;,</span><br><span class="line"> &#x27;information_ratio&#x27;,</span><br><span class="line"> &#x27;kelly_criterion&#x27;,</span><br><span class="line"> &#x27;kurtosis&#x27;,</span><br><span class="line"> &#x27;max_drawdown&#x27;,</span><br><span class="line"> &#x27;monthly_returns&#x27;,</span><br><span class="line"> &#x27;omega&#x27;,</span><br><span class="line"> &#x27;outlier_loss_ratio&#x27;,</span><br><span class="line"> &#x27;outlier_win_ratio&#x27;,</span><br><span class="line"> &#x27;outliers&#x27;,</span><br><span class="line"> &#x27;payoff_ratio&#x27;,</span><br><span class="line"> &#x27;pct_rank&#x27;,</span><br><span class="line"> &#x27;profit_factor&#x27;,</span><br><span class="line"> &#x27;profit_ratio&#x27;,</span><br><span class="line"> &#x27;r2&#x27;,</span><br><span class="line"> &#x27;r_squared&#x27;,</span><br><span class="line"> &#x27;rar&#x27;,</span><br><span class="line"> &#x27;recovery_factor&#x27;,</span><br><span class="line"> &#x27;remove_outliers&#x27;,</span><br><span class="line"> &#x27;risk_of_ruin&#x27;,</span><br><span class="line"> &#x27;risk_return_ratio&#x27;,</span><br><span class="line"> &#x27;rolling_greeks&#x27;,</span><br><span class="line"> &#x27;rolling_sharpe&#x27;,</span><br><span class="line"> &#x27;rolling_sortino&#x27;,</span><br><span class="line"> &#x27;rolling_volatility&#x27;,</span><br><span class="line"> &#x27;ror&#x27;,</span><br><span class="line"> &#x27;serenity_index&#x27;,</span><br><span class="line"> &#x27;sharpe&#x27;,</span><br><span class="line"> &#x27;skew&#x27;,</span><br><span class="line"> &#x27;smart_sharpe&#x27;,</span><br><span class="line"> &#x27;smart_sortino&#x27;,</span><br><span class="line"> &#x27;sortino&#x27;,</span><br><span class="line"> &#x27;tail_ratio&#x27;,</span><br><span class="line"> &#x27;to_drawdown_series&#x27;,</span><br><span class="line"> &#x27;ulcer_index&#x27;,</span><br><span class="line"> &#x27;ulcer_performance_index&#x27;,</span><br><span class="line"> &#x27;upi&#x27;,</span><br><span class="line"> &#x27;value_at_risk&#x27;,</span><br><span class="line"> &#x27;var&#x27;,</span><br><span class="line"> &#x27;volatility&#x27;,</span><br><span class="line"> &#x27;warn&#x27;,</span><br><span class="line"> &#x27;win_loss_ratio&#x27;,</span><br><span class="line"> &#x27;win_rate&#x27;,</span><br><span class="line"> &#x27;worst&#x27;]</span><br></pre></td></tr></table></figure><ol><li>使用quantstats.plots以图形的形式输出绩效指标</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qs.plots.snapshot(stock, title=<span class="string">&quot;TSLA Performance&#x27;)</span></span><br></pre></td></tr></table></figure><p><a href="https://www.zhugetalk.cn/wp-content/uploads/2022/04/2022042406013612.png"><img src="https://www.zhugetalk.cn/wp-content/uploads/2022/04/2022042406013612.png"></a></p><p>支持的全部绘图函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[f <span class="keyword">for</span> f <span class="keyword">in</span> <span class="built_in">dir</span>(qs.plots) <span class="keyword">if</span> f[<span class="number">0</span>] != <span class="string">&#x27;_&#x27;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;daily_returns&#x27;,</span><br><span class="line"> &#x27;distribution&#x27;,</span><br><span class="line"> &#x27;drawdown&#x27;,</span><br><span class="line"> &#x27;drawdowns_periods&#x27;,</span><br><span class="line"> &#x27;earnings&#x27;,</span><br><span class="line"> &#x27;histogram&#x27;,</span><br><span class="line"> &#x27;log_returns&#x27;,</span><br><span class="line"> &#x27;monthly_heatmap&#x27;,</span><br><span class="line"> &#x27;monthly_returns&#x27;,</span><br><span class="line"> &#x27;plotly&#x27;,</span><br><span class="line"> &#x27;returns&#x27;,</span><br><span class="line"> &#x27;rolling_beta&#x27;,</span><br><span class="line"> &#x27;rolling_sharpe&#x27;,</span><br><span class="line"> &#x27;rolling_sortino&#x27;,</span><br><span class="line"> &#x27;rolling_volatility&#x27;,</span><br><span class="line"> &#x27;snapshot&#x27;,</span><br><span class="line"> &#x27;to_plotly&#x27;,</span><br><span class="line"> &#x27;warnings&#x27;,</span><br><span class="line"> &#x27;yearly_returns&#x27;]</span><br></pre></td></tr></table></figure><ol><li>使用quantstats.reports生成综合报表，可保存为html文件</li></ol><p><code>qs.reports.html(stock, &quot;SPY&quot;)</code></p><p>支持输出7种不同的报告:</p><ol><li><code>qs.reports.metrics(mode=&#39;basic|full&quot;, ...)</code> - 展现基础/所有指标</li><li><code>qs.reports.plots(mode=&#39;basic|full&quot;, ...)</code> - 展现基础/所有绘图</li><li><code>qs.reports.basic(...)</code> - 展现基础指标和绘图</li><li><code>qs.reports.full(...)</code> - 展现所有指标和绘图</li><li><code>qs.reports.html(...)</code> - 生成html完整报告</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[f <span class="keyword">for</span> f <span class="keyword">in</span> <span class="built_in">dir</span>(qs.reports) <span class="keyword">if</span> f[<span class="number">0</span>] != <span class="string">&#x27;_&#x27;</span>]</span><br></pre></td></tr></table></figure><p><code>[&#39;basic&#39;, &#39;full&#39;, &#39;html&#39;, &#39;iDisplay&#39;, &#39;iHTML&#39;, &#39;metrics&#39;, &#39;plots&#39;]</code></p><p>quantstats输出的html报表如下，可以看到左边是可视化绩效指标，右边是文字绩效指标。<br><a href="https://www.zhugetalk.cn/wp-content/uploads/2022/04/2022042406020463.png"><img src="https://www.zhugetalk.cn/wp-content/uploads/2022/04/2022042406020463.png"></a></p><p><a href="https://www.zhugetalk.cn/wp-content/uploads/2022/04/2022042406020589.png"><img src="https://www.zhugetalk.cn/wp-content/uploads/2022/04/2022042406020589.png"></a></p><p><a href="https://www.zhugetalk.cn/wp-content/uploads/2022/04/2022042406020677.png"><img src="https://www.zhugetalk.cn/wp-content/uploads/2022/04/2022042406020677.png"></a></p><p><a href="https://www.zhugetalk.cn/wp-content/uploads/2022/04/2022042406020688.png"><img src="https://www.zhugetalk.cn/wp-content/uploads/2022/04/2022042406020688.png"></a><br><a href="https://www.zhugetalk.cn/wp-content/uploads/2022/04/202204240602079.png"><img src="https://www.zhugetalk.cn/wp-content/uploads/2022/04/202204240602079.png"></a></p><h2 id="在backtrader中使用quantstats"><a href="#在backtrader中使用quantstats" class="headerlink" title="在backtrader中使用quantstats"></a>在backtrader中使用quantstats</h2><p>策略绩效评价是量化交易很重要的一环，backtrader提供多种分析者对象analyzer，可以输出各项策略绩效指标，但输出结果是字典方式的数据，没有可视化的绩效报表，而且还缺少一些重要指标，比如索提诺比率（sortino ratio），使用起来不友好。quantstats可以输出html报表，包括各项绩效指标和图表，且可以非常方便地与backtrader集成。</p><p>backtrader使用quantstats示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cerebro.addanalyzer(bt.analyzers.PyFolio, _name=<span class="string">&#x27;pyfolio&#x27;</span>)</span><br><span class="line">strats = cerebro.run()</span><br><span class="line">strat0 = strats[<span class="number">0</span>]</span><br><span class="line">pyfolio = strats.analyzers.getbyname(<span class="string">&#x27;pyfolio&#x27;</span>)</span><br><span class="line">returns, positions, transactions, gross_lev = pyfoliozer.get_pf_items()</span><br><span class="line"><span class="built_in">print</span>(returns)</span><br><span class="line">returns.index = returns.index.tz_convert(<span class="literal">None</span>)</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> quantstats</span><br><span class="line">quantstats.reports.html(returns, output=<span class="string">&#x27;stats.html&#x27;</span>, title=<span class="string">&#x27;Stock Sentiment&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h2><p>欢迎大家留言，关注微信公众号多多交流，最新的文章会优先发布在微信公众号上。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/ranaroussi/quantstats">quantstats github</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ranaroussi/quantstats&quot;&gt;quantstats&lt;/a&gt; – 衡量</summary>
      
    
    
    
    <category term="quant" scheme="https://rchardzhu.github.io/categories/quant/"/>
    
    
    <category term="quant" scheme="https://rchardzhu.github.io/tags/quant/"/>
    
    <category term="backtrader" scheme="https://rchardzhu.github.io/tags/backtrader/"/>
    
    <category term="quantstats" scheme="https://rchardzhu.github.io/tags/quantstats/"/>
    
  </entry>
  
  <entry>
    <title>empyrical、pyfolio工具介绍及在backtrader量化框架中使用</title>
    <link href="https://rchardzhu.github.io/2022/04/23/about-empyrical-pyfolio-and-using-in-backtrader/"/>
    <id>https://rchardzhu.github.io/2022/04/23/about-empyrical-pyfolio-and-using-in-backtrader/</id>
    <published>2022-04-23T11:45:03.000Z</published>
    <updated>2022-04-23T11:47:14.351Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><a href="https://github.com/quantopian/empyrical">empyrical</a> – Quantopian开源的常见金融风险指标lib库，会调用pandas_datareader从yahoo或google获取股票数据</li><li><a href="https://github.com/quantopian/pyfolio">pyfolio</a> – Quantopian开源的用图形表示的金融投资组合性能和风险分析的Python库，基于empyrical获取数据和计算基础指标，由各种各样的独立图组成，这些图提供了交易策略表现的综合图像。图形示例可以参考<a href="https://github.com/quantopian/pyfolio/blob/master/pyfolio/examples/full_tear_sheet_example.ipynb">full_tear_sheet_example.ipynb</a></li></ul><h2 id="empyrical安装-amp-使用"><a href="#empyrical安装-amp-使用" class="headerlink" title="empyrical安装&amp;使用"></a>empyrical安装&amp;使用</h2><ul><li>安装：<code>pip install empyrical</code></li><li>使用方法：<br>以计算最大回撤和alpha、beta为例，代码如下。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> empyrical <span class="keyword">import</span> max_drawdown, alpha_beta</span><br><span class="line">returns = np.array([<span class="number">.01</span>, <span class="number">.02</span>, <span class="number">.03</span>, -<span class="number">.4</span>, -<span class="number">.06</span>, -<span class="number">.02</span>])</span><br><span class="line">benchmark_returns = np.array([<span class="number">.02</span>, <span class="number">.02</span>, <span class="number">.03</span>, -<span class="number">.35</span>, -<span class="number">.05</span>, -<span class="number">.01</span>])</span><br><span class="line">max_drawdown(returns) <span class="comment"># 计算最大回撤</span></span><br><span class="line">alpha, beta = alpha_beta(returns, benchmark_returns) <span class="comment"># 计算alpha和beta</span></span><br><span class="line">returns = pd.Series([<span class="number">.01</span>, <span class="number">.02</span>, <span class="number">.03</span>, -<span class="number">.4</span>, -<span class="number">.06</span>, -<span class="number">.02</span>]) <span class="comment">#支持pd.Series()</span></span><br><span class="line">max_drawdown(returns)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看empyrical支持的api列表，如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> empyrical</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(empyrical))</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;DAILY&#x27;, &#x27;MONTHLY&#x27;, &#x27;QUARTERLY&#x27;, &#x27;WEEKLY&#x27;, &#x27;YEARLY&#x27;, &#x27;__builtins__&#x27;, &#x27;__cached__&#x27;, &#x27;__doc__&#x27;, &#x27;__file__&#x27;, &#x27;__loader__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;__path__&#x27;, &#x27;__spec__&#x27;, &#x27;__version__&#x27;, &#x27;_version&#x27;, &#x27;aggregate_returns&#x27;, &#x27;alpha&#x27;, &#x27;alpha_aligned&#x27;, &#x27;alpha_beta&#x27;, &#x27;alpha_beta_aligned&#x27;, &#x27;annual_return&#x27;, &#x27;annual_volatility&#x27;, &#x27;beta&#x27;, &#x27;beta_aligned&#x27;, &#x27;beta_fragility_heuristic&#x27;, &#x27;beta_fragility_heuristic_aligned&#x27;, &#x27;cagr&#x27;, &#x27;calmar_ratio&#x27;, &#x27;capture&#x27;, &#x27;compute_exposures&#x27;, &#x27;conditional_value_at_risk&#x27;, &#x27;cum_returns&#x27;, &#x27;cum_returns_final&#x27;, &#x27;deprecate&#x27;, &#x27;down_alpha_beta&#x27;, &#x27;down_capture&#x27;, &#x27;downside_risk&#x27;, &#x27;excess_sharpe&#x27;, &#x27;gpd_risk_estimates&#x27;, &#x27;gpd_risk_estimates_aligned&#x27;, &#x27;max_drawdown&#x27;, &#x27;omega_ratio&#x27;, &#x27;perf_attrib&#x27;, &#x27;periods&#x27;, &#x27;roll_alpha&#x27;, &#x27;roll_alpha_aligned&#x27;, &#x27;roll_alpha_beta&#x27;, &#x27;roll_alpha_beta_aligned&#x27;, &#x27;roll_annual_volatility&#x27;, &#x27;roll_beta&#x27;, &#x27;roll_beta_aligned&#x27;, &#x27;roll_down_capture&#x27;, &#x27;roll_max_drawdown&#x27;, &#x27;roll_sharpe_ratio&#x27;, &#x27;roll_sortino_ratio&#x27;, &#x27;roll_up_capture&#x27;, &#x27;roll_up_down_capture&#x27;, &#x27;sharpe_ratio&#x27;, &#x27;simple_returns&#x27;, &#x27;sortino_ratio&#x27;, &#x27;stability_of_timeseries&#x27;, &#x27;stats&#x27;, &#x27;tail_ratio&#x27;, &#x27;up_alpha_beta&#x27;, &#x27;up_capture&#x27;, &#x27;up_down_capture&#x27;, &#x27;utils&#x27;, &#x27;value_at_risk&#x27;]</span><br></pre></td></tr></table></figure><p>顺便说明下，empyrical官方api手册不全，看api文档使用help来看比较方便，如<code>help(empyrical.excess_sharpe)</code>。</p><h2 id="pyfolio安装-amp-使用"><a href="#pyfolio安装-amp-使用" class="headerlink" title="pyfolio安装&amp;使用"></a>pyfolio安装&amp;使用</h2><p>pyfolio只能在jupyter notebook环境下完整绘图，在命令行环境或py文件下可以单独画图，但不能显示表格数据。</p><p>通常的误区是：pyfolio只能在jupyter下使用。正确的说法是pyfolio对jupyter环境下支持的最好。</p><ul><li>安装：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install git+https://github.com/quantopian/pyfolio</span><br></pre></td></tr></table></figure><p>使用pip install pyfolio，在使用的时候会报错，下面会说明。</p><ul><li>使用方法：</li></ul><ol><li>构造数据<br>产出如下数据，格式为pd.series。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.head()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Date</span><br><span class="line">2017-04-25 00:00:00+00:00    0.018699</span><br><span class="line">2017-04-26 00:00:00+00:00   -0.011536</span><br><span class="line">2017-04-27 00:00:00+00:00   -0.004965</span><br><span class="line">2017-04-28 00:00:00+00:00    0.017626</span><br><span class="line">2017-05-01 00:00:00+00:00    0.027892</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><ol><li>使用pyfolio</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyfolio <span class="keyword">as</span> pf</span><br><span class="line">pf.create_returns_tear_sheet(data)</span><br><span class="line">pf.plot_drawdown_periods(data)</span><br></pre></td></tr></table></figure><p>在jupyter中运行，结果如下：<br><a href="/wp-content/uploads/2022/04/2022042311075489.png"><img src="https://www.zhugetalk.cn/wp-content/uploads/2022/04/2022042311075489.png"></a><br><a href="/wp-content/uploads/2022/04/2022042311084092.png"><img src="https://www.zhugetalk.cn/wp-content/uploads/2022/04/2022042311084092.png"></a><br><a href="/wp-content/uploads/2022/04/2022042311084143.png"><img src="https://www.zhugetalk.cn/wp-content/uploads/2022/04/2022042311084143.png"></a><br><a href="/wp-content/uploads/2022/04/2022042311084282.png"><img src="https://www.zhugetalk.cn/wp-content/uploads/2022/04/2022042311084282.png"></a><br><a href="/wp-content/uploads/2022/04/2022042311093652.png"><img src="https://www.zhugetalk.cn/wp-content/uploads/2022/04/2022042311093652.png"></a></p><p> 在ipython运行，结果如下：<br><a href="/wp-content/uploads/2022/04/2022042311093711.png"><img src="https://www.zhugetalk.cn/wp-content/uploads/2022/04/2022042311093711.png"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">8</span>]: pf.create_returns_tear_sheet(data)</span><br><span class="line">&lt;IPython.core.display.HTML <span class="built_in">object</span>&gt;</span><br><span class="line">&lt;IPython.core.display.HTML <span class="built_in">object</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: ret = pf.create_returns_tear_sheet(data)</span><br><span class="line">&lt;IPython.core.display.HTML <span class="built_in">object</span>&gt;</span><br><span class="line">&lt;IPython.core.display.HTML <span class="built_in">object</span>&gt;</span><br><span class="line"></span><br><span class="line">pf.plot_drawdown_periods(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><a href="https://www.zhugetalk.cn/wp-content/uploads/2022/04/2022042311103615.png"><img src="https://www.zhugetalk.cn/wp-content/uploads/2022/04/2022042311103615.png"></a></p><ul><li>查看支持的函数：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(pf))</span><br></pre></td></tr></table></figure><p><code>[&#39;APPROX_BDAYS_PER_MONTH&#39;, &#39;FACTOR_PARTITIONS&#39;, &#39;FigureCanvasAgg&#39;, &#39;FuncFormatter&#39;, &#39;MM_DISPLAY_UNIT&#39;, &#39;Markdown&#39;, &#39;OrderedDict&#39;, &#39;STAT_FUNCS_PCT&#39;, &#39;__all__&#39;, &#39;__builtins__&#39;, &#39;__cached__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__path__&#39;, &#39;__spec__&#39;, &#39;__version__&#39;, &#39;_seaborn&#39;, &#39;_version&#39;, &#39;axes_style&#39;, &#39;capacity&#39;, &#39;create_capacity_tear_sheet&#39;, &#39;create_full_tear_sheet&#39;, &#39;create_interesting_times_tear_sheet&#39;, &#39;create_perf_attrib_tear_sheet&#39;, &#39;create_position_tear_sheet&#39;, &#39;create_returns_tear_sheet&#39;, &#39;create_round_trip_tear_sheet&#39;, &#39;create_simple_tear_sheet&#39;, &#39;create_txn_tear_sheet&#39;, &#39;customize&#39;, &#39;datetime&#39;, &#39;deprecate&#39;, &#39;display&#39;, &#39;division&#39;, &#39;ep&#39;, &#39;figure&#39;, &#39;gridspec&#39;, &#39;interesting_periods&#39;, &#39;matplotlib&#39;, &#39;np&#39;, &#39;patches&#39;, &#39;pd&#39;, &#39;perf_attrib&#39;, &#39;plot_annual_returns&#39;, &#39;plot_capacity_sweep&#39;, &#39;plot_cones&#39;, &#39;plot_daily_turnover_hist&#39;, &#39;plot_daily_volume&#39;, &#39;plot_drawdown_periods&#39;, &#39;plot_drawdown_underwater&#39;, &#39;plot_exposures&#39;, &#39;plot_gross_leverage&#39;, &#39;plot_holdings&#39;, &#39;plot_long_short_holdings&#39;, &#39;plot_max_median_position_concentration&#39;, &#39;plot_monthly_returns_dist&#39;, &#39;plot_monthly_returns_heatmap&#39;, &#39;plot_monthly_returns_timeseries&#39;, &#39;plot_perf_stats&#39;, &#39;plot_prob_profit_trade&#39;, &#39;plot_return_quantiles&#39;, &#39;plot_returns&#39;, &#39;plot_rolling_beta&#39;, &#39;plot_rolling_returns&#39;, &#39;plot_rolling_sharpe&#39;, &#39;plot_rolling_volatility&#39;, &#39;plot_round_trip_lifetimes&#39;, &#39;plot_sector_allocations&#39;, &#39;plot_slippage_sensitivity&#39;, &#39;plot_slippage_sweep&#39;, &#39;plot_turnover&#39;, &#39;plot_txn_time_hist&#39;, &#39;plotting&#39;, &#39;plotting_context&#39;, &#39;plt&#39;, &#39;pos&#39;, &#39;pytz&#39;, &#39;round_trips&#39;, &#39;show_and_plot_top_positions&#39;, &#39;show_perf_stats&#39;, &#39;show_profit_attribution&#39;, &#39;show_worst_drawdown_periods&#39;, &#39;sns&#39;, &#39;sp&#39;, &#39;tears&#39;, &#39;time&#39;, &#39;timer&#39;, &#39;timeseries&#39;, &#39;txn&#39;, &#39;utils&#39;, &#39;warnings&#39;, &#39;wraps&#39;]</code></p><ul><li>常见错误</li></ul><ol><li>报错：<strong>ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all()</strong></li></ol><p>解决办法：pf.create_returns_tear_sheet()的参数是pd.series，不能是pd.dataframe</p><ol><li>报错：<strong>AttributeError: ‘numpy.int64’ object has no attribute ‘to_pydatetime’</strong></li></ol><p>解决办法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install git+https://github.com/quantopian/pyfolio</span><br></pre></td></tr></table></figure><h2 id="在backtrader中使用PyFolio"><a href="#在backtrader中使用PyFolio" class="headerlink" title="在backtrader中使用PyFolio"></a>在backtrader中使用PyFolio</h2><p>pyfolio改变过api接口，<code>create_full_tear_sheet()函数后面没有了gross_lev</code>参数，使用backtrade网站的示例代码会报错。 参考pyfolio官方的使用文档即可。</p><p>backtrader使用pyfolio示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cerebro.addanalyzer(bt.analyzers.PyFolio, _name=<span class="string">&#x27;pyfolio&#x27;</span>)</span><br><span class="line">strats = cerebro.run()</span><br><span class="line">strat0 = strats[<span class="number">0</span>]</span><br><span class="line">pyfolio = strats.analyzers.getbyname(<span class="string">&#x27;pyfolio&#x27;</span>)</span><br><span class="line">returns, positions, transactions, gross_lev = pyfoliozer.get_pf_items()</span><br><span class="line"><span class="keyword">import</span> pyfolio <span class="keyword">as</span> pf</span><br><span class="line">pf.create_full_tear_sheet(returns)</span><br></pre></td></tr></table></figure><h2 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h2><p>欢迎大家留言，关注微信公众号多多交流，最新的文章会优先发布在微信公众号上。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/quantopian/empyrical">empyrical github</a></li><li><a href="https://github.com/quantopian/empyrical/blob/master/empyrical/__init__.py">empyrical API列表</a></li><li><a href="https://github.com/quantopian/pyfolio">pyfolio github</a></li><li><a href="https://quantopian.github.io/pyfolio/">pyfolio文档</a></li><li><strong><strong><a href="https://nbviewer.org/format/slides/github/quantopian/pyfolio/blob/master/pyfolio/examples/pyfolio_talk_slides.ipynb#/">Portfolio and Risk Analytics in Python with pyfolio</a></strong></strong></li><li><a href="https://www.backtrader.com/docu/analyzers/pyfolio/">backtrader pyfolio分析器介绍</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/quantopian/empyrical&quot;&gt;empyrical&lt;/a&gt; </summary>
      
    
    
    
    <category term="quant" scheme="https://rchardzhu.github.io/categories/quant/"/>
    
    
    <category term="quant" scheme="https://rchardzhu.github.io/tags/quant/"/>
    
    <category term="backtrader" scheme="https://rchardzhu.github.io/tags/backtrader/"/>
    
    <category term="empyrical" scheme="https://rchardzhu.github.io/tags/empyrical/"/>
    
    <category term="pyfolio" scheme="https://rchardzhu.github.io/tags/pyfolio/"/>
    
  </entry>
  
  <entry>
    <title>使用markdown写书</title>
    <link href="https://rchardzhu.github.io/2022/04/10/write-book-with-markdown/"/>
    <id>https://rchardzhu.github.io/2022/04/10/write-book-with-markdown/</id>
    <published>2022-04-10T05:01:56.000Z</published>
    <updated>2022-04-10T05:08:10.477Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用markdown写文档越来越多了，有些成体系的文章希望逐步整理成小册子或者小文档，不排除后面有时间了整理成书籍。<br>于是调研了下专门用于制作电子书类文档的工具，之前听说比较多的是gitbook和Read the Docs。不过gitbook的开源版本2018年末就不更新了，尝试折腾了挺久都不好使。于是网上找到了几个候选：mdbook、bookdown、mkdocs、gohugo、和peach。mdbook则是用rust语言实现的， 只有一个单独的命令行程序，能够实时渲染，最近开发迭代还比较多。<br>bookdown是r语言实现的，依赖于RStudio集成环境制作；mkdocs是python实现的，gohugo和peach是go语言实现的。由于mdbook尝试了下能够比较好的满足我的需求，其他就没有深入去尝试了，感兴趣的读者可以自己去试试。</p><h2 id="mdbook介绍"><a href="#mdbook介绍" class="headerlink" title="mdbook介绍"></a>mdbook介绍</h2><p>mdbook是一个用markdown来创建书籍的命令行工具，非常适合用来创建产品、api文档、手册、课程材料等。<br>特点：</p><ul><li>轻量级markdown语法</li><li>集成了搜索功能</li><li>代码块语法高亮支持</li><li>多个主题支持</li><li>快速、安全、简单</li><li>书籍The Rust Programming Language book也在使用mdbook来编写</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>手动下载安装<br>去github 下载，点<a href="https://github.com/rust-lang/mdBook/releases">下载链接</a>，支持windows, mac, linux。<br>下载解压后，将mdbook放到/usr/local/bin下即可使用</p></li><li><p>mac可以使用brew安装，安装的版本可能不是最新，但比较方便</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install  mdbook</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir my-quant-book</span><br><span class="line">cd my-quant-book</span><br><span class="line">mdbook init # 会提示输入文档标题</span><br><span class="line">mdbook serve</span><br></pre></td></tr></table></figure><p>浏览器输入<a href="http://localhost:3000/">http://localhost:3000/</a>  就可以看到书籍了。<br>在my-quant-book下生成了book和src两个文件夹和book.toml一个配置文件。<br>在src目录下自动生成了SUMMARY.md和chapter_1.md 2个markdown文件。chapter_1.md和普通markdown文件一样，SUMMARY.md比较特殊，用来表示文档包含那些文件以及他们的顺序是咋样的。</p><p>mdbook服务默认启动端口是3000，如果需要更改端口，可以使用-p参数，如<code>mdbook serve -p 3001</code> 将端口改为3001。</p><p>其他跟markdown一样正常编辑就好了。不知道markdown语法的可以参考我的另外一篇《markdown实战》文章。</p><h2 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h2><p>欢迎关注微信公众号交流～</p><ul><li>微信公众号：诸葛说talk</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://rust-lang.github.io/mdBook/">mdbook使用说明</a></li><li><a href="https://rust-lang.github.io/mdBook/format/summary.html">mdbook summary文件说明</a></li><li><a href="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/bookdown.html">用bookdown制作图书</a></li><li><a href="https://www.mkdocs.org/">mkdocs</a></li><li><a href="https://blog.csdn.net/bigwhite20xx/article/details/107011017">gohugo、mdbook和peach比拼</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近使用markdown写文档越来越多了，有些成体系的文章希望逐步整理成小册子或者小文档，不排除后面有时间了整理成书籍。&lt;br&gt;于是调研了下专门用于制作电子书类文档的工具，之前听说比较多的是gitbook和Read the Docs。不过gitbook的开源版本2018年末</summary>
      
    
    
    
    <category term="blog" scheme="https://rchardzhu.github.io/categories/blog/"/>
    
    <category term="tool" scheme="https://rchardzhu.github.io/categories/tool/"/>
    
    
    <category term="markdown" scheme="https://rchardzhu.github.io/tags/markdown/"/>
    
    <category term="blog" scheme="https://rchardzhu.github.io/tags/blog/"/>
    
    <category term="mdbook" scheme="https://rchardzhu.github.io/tags/mdbook/"/>
    
  </entry>
  
  <entry>
    <title>TA-Lib介绍及在backtrader框架中使用</title>
    <link href="https://rchardzhu.github.io/2022/04/10/about-talib/"/>
    <id>https://rchardzhu.github.io/2022/04/10/about-talib/</id>
    <published>2022-04-10T04:00:00.000Z</published>
    <updated>2022-04-10T04:23:55.333Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、TA-Lib介绍"><a href="#一、TA-Lib介绍" class="headerlink" title="一、TA-Lib介绍"></a>一、TA-Lib介绍</h2><ul><li><a href="https://ta-lib.org/">TA-Lib</a> – 交易软件开发广泛使用的技术分析lib，包括了200多个技术指标，如MACD, RSI等</li><li><a href="https://mrjbq7.github.io/ta-lib/">ta-lib for python</a> – python封装的ta-lib。python封装的ta-lib，使用Cython和Numpy高效实现，比使用SWIG接口的原始版本快2-4倍</li></ul><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><p>mac安装方法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew install ta-lib</span><br><span class="line">$ pip install TA-Lib</span><br></pre></td></tr></table></figure><p>如果没用brew安装ta-lib，会报如下错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func.c:256:28: fatal error: ta-lib/ta_libc.h: No such file or directory</span><br><span class="line">compilation terminated.</span><br><span class="line">If you get build errors like this, it typically means that it can&#x27;t find the underlying TA-Lib library and needs to be installed:</span><br></pre></td></tr></table></figure><p>windows、linux参考：<a href="https://mrjbq7.github.io/ta-lib/install.html">https://mrjbq7.github.io/ta-lib/install.html</a></p><p>进python使用<code>import talib</code>没有报错的话，表明安装成功。</p><h2 id="三、常用指标使用"><a href="#三、常用指标使用" class="headerlink" title="三、常用指标使用"></a>三、常用指标使用</h2><ol><li>SMA：简单移动平均线(Simple Moving Average)<br>talib.SMA() 要求数据是numpy.ndarray格式<br>talib.abstract.SMA() 要求数据是Numpy数组的字典格式</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import talib</span><br><span class="line"></span><br><span class="line">close = np.random.random(100)</span><br><span class="line">output = talib.SMA(close) # 默认是SMA30</span><br><span class="line">output = talib.SMA(close, timeperiod=5) # SMA5</span><br><span class="line"></span><br><span class="line">inputs = &#123;</span><br><span class="line">    &#x27;open&#x27;: np.random.random(100),</span><br><span class="line">    &#x27;high&#x27;: np.random.random(100),</span><br><span class="line">    &#x27;low&#x27;: np.random.random(100),</span><br><span class="line">    &#x27;close&#x27;: np.random.random(100),</span><br><span class="line">    &#x27;volume&#x27;: np.random.random(100)</span><br><span class="line">&#125;</span><br><span class="line">from talib.abstract import *</span><br><span class="line">output = SMA(input_arrays, timeperiod=25) # 默认对close价格计算</span><br><span class="line">output = SMA(input_arrays, timeperiod=25, price=&#x27;open&#x27;) # 对open价格计算</span><br></pre></td></tr></table></figure><ol start="2"><li><p>EMA：指数移动平均线(Exponential Moving Average)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">talib.EMA(close)</span><br><span class="line">talib.abstract.EMA(inputs)</span><br></pre></td></tr></table></figure></li><li><p>MACD：平滑异同移动平均线(Moving Average Convergence / Divergence)<br>通过三种数据的信号（均线的组合 ）可以判断趋势的力量和方向并确定趋势的转折点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">talib.MACD(close)</span><br><span class="line">talib.abstract.MACD(inputs)</span><br></pre></td></tr></table></figure></li><li><p>支持的指标列表</p></li></ol><ul><li>均线指标，如EMA、SMA、WMA等</li><li>动量指标，如MACD、MOM、RSI等</li><li>成交量指标，如AD、OBV等</li><li>易变指标，如ATR、NATR等</li><li>价格变换，如AVGPRICE、MEDPRICE等</li><li>循环指标，如HT_DCPERIOD、HT_SINE等</li><li>模式识别，如CDL2CROWS、CDLHAMMER等</li><li>统计函数，如VAR,STDDEV, LINEARREG等</li><li>数学变换，如ACOS、ASIN、CEIL、COS、EXP、LN、SQRT等</li><li>数学操作，如ADD、DIV、MAX、MULT、SUM等</li></ul><p>支持的功能及函数列表如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import talib</span><br><span class="line">talib.get_functions()</span><br><span class="line">print(len(talib.get_functions()))</span><br><span class="line">talib.get_function_groups()</span><br><span class="line">print(len(talib.get_function_groups()))</span><br></pre></td></tr></table></figure><h2 id="四、在backtrader中调用TA-Lib库"><a href="#四、在backtrader中调用TA-Lib库" class="headerlink" title="四、在backtrader中调用TA-Lib库"></a>四、在backtrader中调用TA-Lib库</h2><p>为了满足大家的使用习惯，Backtrader也接入了 TA-Lib 技术指标库，具体信息可以查阅<a href="https://www.backtrader.com/docu/talibindautoref/">官方 document</a>，文档中对各个函数的输入、输出，以及在 Backtrader 中特有的绘图参数、返回的 lines 属性等信息都做了介绍和说明。TA-Lib 指标函数的调用形式为 bt.talib.xxx，跟直接使用ta-lib区别不大 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class TALibStrategy(bt.Strategy):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 计算 5 日均线</span><br><span class="line">        bt.talib.SMA(self.data.close, timeperiod=5)</span><br><span class="line">        bt.indicators.SMA(self.data, period=5)</span><br><span class="line">        # 计算布林带</span><br><span class="line">        bt.talib.BBANDS(self.data, timeperiod=25)</span><br><span class="line">        bt.indicators.BollingerBands(self.data, period=25)</span><br></pre></td></tr></table></figure><h2 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h2><p>欢迎关注微信公众号交流，最新的文章会优先发布在微信公众号上。</p><ul><li>微信公众号：诸葛说talk</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://ta-lib.org/">TA-Lib官网</a></li><li><a href="https://ta-lib.org/function.html">Ta-lib函数列表</a></li><li><a href="https://mrjbq7.github.io/ta-lib/">ta-lib for python</a></li><li><a href="https://mrjbq7.github.io/ta-lib/install.html">ta-lib python安装</a></li><li><a href="https://www.backtrader.com/docu/talibindautoref/">backtrader ta-lib技术指标api</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、TA-Lib介绍&quot;&gt;&lt;a href=&quot;#一、TA-Lib介绍&quot; class=&quot;headerlink&quot; title=&quot;一、TA-Lib介绍&quot;&gt;&lt;/a&gt;一、TA-Lib介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ta-lib.org/&quot;&gt;TA</summary>
      
    
    
    
    <category term="quant" scheme="https://rchardzhu.github.io/categories/quant/"/>
    
    
    <category term="quant" scheme="https://rchardzhu.github.io/tags/quant/"/>
    
    <category term="backtrader" scheme="https://rchardzhu.github.io/tags/backtrader/"/>
    
    <category term="talib" scheme="https://rchardzhu.github.io/tags/talib/"/>
    
  </entry>
  
  <entry>
    <title>一文读懂ios归因框架SKAdNetwork</title>
    <link href="https://rchardzhu.github.io/2022/04/09/about-ios-skadnetwork/"/>
    <id>https://rchardzhu.github.io/2022/04/09/about-ios-skadnetwork/</id>
    <published>2022-04-09T03:45:03.000Z</published>
    <updated>2022-04-09T03:49:23.709Z</updated>
    
    <content type="html"><![CDATA[<p>最近很多人在咨询 SKA 框架的情况，整理了一些资料，欢迎交流沟通~</p><h2 id="1-什么是SKAdNetwork？"><a href="#1-什么是SKAdNetwork？" class="headerlink" title="1. 什么是SKAdNetwork？"></a>1. 什么是<strong>SKAdNetwork</strong>？</h2><p>SKAdNetwork 是 Apple于2018年5月推出 的归因框架，可以在保护用户隐私的同时进行APP归因，但之前由于idfa 获取不需每个 app 单独授权，SKAdNetwork并没有得到广泛使用。 直至2020年6月22日举行的WWDC（全球开发者大会）上，苹果宣布了在 iOS 14 系统中，App 在获取 IDFA 时需要明确请求用户的许可。这就意味着如果未经过用户允许将获取不到 idfa，这让过去通过 IDFA 来实现的广告归因和效果衡量变得接近无效或者效果损失很大。 我们在广告系统中确实遇到了 cvr 大幅下降的问题，随着 ios 14.5之后的 ios 版本覆盖越来越多，归因问题越来越严重。SKN 框架也得到了越来越多人的重视。</p><h2 id="2-SkAdNetwork的优点和缺点是什么？"><a href="#2-SkAdNetwork的优点和缺点是什么？" class="headerlink" title="2. SkAdNetwork的优点和缺点是什么？"></a>2. SkAdNetwork的优点和缺点是什么？</h2><p>SKAdNetwork的优势是确定性归因，其能提供几乎 100% 精确的归因。有数据表明，与 IDFA 精确归因相比，SKAdNetwork 的准确性只差了 2%。需要说明的是，如果某个推广活动之前通过 IDFA 归因获得了 1000 次安装归因，SKAdNetwork 可能会归因 900 次安装和 100 次重装。这是因为 SKAdNetwork 只会为每个 iTunes 账户归因一次安装。因此，为了与 ATT (AppTrackingTransparency授权弹窗)执行前的情况保持一致，分析安装和重装的总量非常重要。</p><p>SKAdNetwork 的缺点是无法像 IDFA 一样实时将转化跟点击精确关联起来。 具体如下：</p><ul><li>无法精确归因到点击，原因是无法将点击标记和转化精确关联起来。</li><li>无法实时归因，SKA框架最少 24 至 48 小时的转化数据延迟回传。</li><li>SKAdNetwork 框架下每个渠道仅显示 100 个不同的推广活动，且能提供的数据信号非常有限，这对于稍微大点的客户来说经常不够用。 按照当前的计划，SKAdNetwork 会提供长度为 6 比特的下游指标，且有 24 小时的时间限制。每次用户触发应用内事件，该 6 比特指标就会发生变化，成为应用指定的全新 6 比特事件识别码，而时间限制也会延长 24 小时。事件窗口过期后，第二个 24 小时归因窗口就会开始计时。SKAdNetwork 会在这 24 小时窗口内随机返回归因数据。</li><li>未涵盖所有的归因链路，比如移动网页端就无法归因</li><li>由于无法实时精确归因，导致归因流程中作弊风险大幅加大。同时数据由广告平台所有并提供报告，会导致不信任感加大，当然这块 ios 也在升级解决中。</li></ul><h2 id="3-SkAdNetwork怎么用？"><a href="#3-SkAdNetwork怎么用？" class="headerlink" title="3. SkAdNetwork怎么用？"></a>3. SkAdNetwork怎么用？</h2><p><img src="https://docs-assets.developer.apple.com/published/e3e8f2b5fc/StoreKit-AdNetwork_overview@2x.png" alt="Diagram showing a user tapping an ad for app B inside of app A, then installing and launching app B, which triggers a conversion notification after app B calls one of two methods, and after the timer expires. The ad network receives the postback which it must verify."><br>SKA框架流程如上图所示，看了上面的说明，基本能知道每个步骤是在干啥了，不展开说明了。下面说明下各个参与方都需要做什么。</p><h3 id="3-1-广告平台-广告网络需要做什么？"><a href="#3-1-广告平台-广告网络需要做什么？" class="headerlink" title="3.1 广告平台/广告网络需要做什么？"></a>3.1 广告平台/广告网络需要做什么？</h3><p>这里的广告平台包括腾讯、阿里、字节、百度等头部媒体，也包括appsflyer、adjust、热云等第三方平台。</p><p>a) 在Apple 上注册Network ID，用于在广告活动时使用归因验证的各种API。</p><p>b) 为流量媒体侧App（Source App）提供已签名的广告应用。广告平台（Ad Network）在收到媒体端的广告请求时为广告应用进行签名（可以理解为生成一个广告的追踪ID）。</p><p>c) 通过注册的回包网址（Postback URL）接收来自广告主回传的激活和转化信息；</p><p>d) 确认已接收广告主回传的信息。</p><h3 id="3-2-媒体需要做什么？"><a href="#3-2-媒体需要做什么？" class="headerlink" title="3.2 媒体需要做什么？"></a>3.2 媒体需要做什么？</h3><ol><li>需要在媒体应用的Info.plist 上添加广告网络的ID；</li><li>展示已签名的广告。 在广告即将曝光前，调用系统的loadProduct(withParameters:completionBlock) 函数，用于预加载一个App Store的web端或者客户端的广告展示落地页。这样可以提升广告展示的速度，同时，将广告的应用相关签名信息和广告网络ID（Ad network ID）等信息传给App Store。</li></ol><h3 id="3-3-广告主-开发者需要做什么？"><a href="#3-3-广告主-开发者需要做什么？" class="headerlink" title="3.3 广告主/开发者需要做什么？"></a>3.3 广告主/开发者需要做什么？</h3><ol><li>在应用安装激活后，应用调用系统的API registerAppForAdNetworkAttribution或updateConversionValue函数发送激活或其他转化信息</li><li>如果此次安装有归因数据，那么应用首次调用函数registerAppForAdNetworkAttribution 会生成通知，并且启动一个 24 小时计时器，再次调用该函数没有反应。但是可以调用 updateConversionValue函数提供转化数值并且重启计时器。在计时器结束后的 0-24 小时内设备会将安装通知发送给广告网络，广告网络在收到通知后必须进行验证</li><li>updateConversionValue函数的参数为conversionValue，类型为无符号的 6 bit 整数（0-63）。由广告主应用和广告网络决定此值的含义，默认值为0。开发者可以在 24小时的循环周期内反复调用 updateConversionValue函数来更新转化数值。转化数值是由广告网络或者广告主定义的 6 bit 值。App在计时器结束前可以随意调用。每次调用，只要这个值比上一次大，计时器就会重新计时。当计时器结束，最后的数值将生效。之后继续调用 updateConversionValue 无任何作用。在计时器结束后的 0-24 小时内设备将安装通知发送给广告网络。</li><li>SKAdNetwork 系统分享的数据都采取聚合形式，不提供用户层级上的精细数据，事件识别码只能向上叠进。只要这个值比上一次大，计时器就会重新计时。要解决这个问题，开发者需要为排列组合中所有的可能性分配不同的比特值，而不是为每种事件分配比特值。</li></ol><h2 id="4-归因的时间窗口是多少？"><a href="#4-归因的时间窗口是多少？" class="headerlink" title="4. 归因的时间窗口是多少？"></a>4. 归因的时间窗口是多少？</h2><p>从广告曝光到广告网络接收到安装验证的消息最小延迟是24-48小时，测试的时候可以缩小到5-10分钟，具体可以参考<a href="https://developer.apple.com/documentation/storekit/skadnetwork/testing_ad_attributions_with_a_downloaded_profile">Testing Ad Attributions with a Downloaded Profile</a>. 各个事件有最长归因时间窗口，超过该窗口发生的转化无法归因到对应的事件上，具体如下。</p><table><thead><tr><th align="left">事件</th><th align="left">时间窗口</th></tr></thead><tbody><tr><td align="left">广告网络展示了一个StoreKit渲染的广告</td><td align="left">用户有30天的时间窗口来安装 app</td></tr><tr><td align="left">广告网链展示了一个浏览广告</td><td align="left">用户有24小时窗口来安装 app</td></tr><tr><td align="left">用户安装了 app</td><td align="left">用户有60天窗口来启动 app</td></tr><tr><td align="left">用户启动 app 且 app 调用了 <a href="https://developer.apple.com/documentation/storekit/skadnetwork/2943654-registerappforadnetworkattributi"><code>registerAppForAdNetworkAttribution()</code></a>函数</td><td align="left">设备在24小时定时器到期后在0-24小时内随机发送安装-验证回传信号</td></tr><tr><td align="left">用户启动 app 且 app 调用了<a href="https://developer.apple.com/documentation/storekit/skadnetwork/3566697-updateconversionvalue">updateConversionValue</a>函数</td><td align="left">设备在最后一次调用updateConversionValue函数的24小时定时器到期后在0-24小时内随机发送安装-验证回传信号</td></tr></tbody></table><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul><li>IDFV - Identifier For Vendor（应用开发商标识符）</li><li>IDFA - Identifier For Advertising（广告标识符）</li><li>mmp - mobile measure partner (移动成效衡量合作伙伴)</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.apple.com/documentation/storekit/skadnetwork">SKAdNetwork类说明</a></li><li><a href="https://developer.apple.com/documentation/storekit/skadnetwork/2943654-registerappforadnetworkattributi?language=objc">registerAppForAdNetworkAttribution函数说明</a></li><li><a href="https://developer.apple.com/documentation/storekit/skadnetwork/3566697-updateconversionvalue?language=objc">updateConversionValue函数说明</a></li><li><a href="https://developer.apple.com/documentation/storekit/skadnetwork/receiving_ad_attributions_and_postbacks">接收广告归因</a></li><li><a href="https://developer.apple.com/documentation/storekit/skstoreproductparameteradnetworkcampaignidentifier">SKStoreProductParameterAdNetworkCampaignIdentifier</a> – 广告网络计划标记符</li><li><a href="https://zhuanlan.zhihu.com/p/358829987">匹配式归因，链路式归因以及IOS SKAdNetwork归因说明</a></li><li>appsflyer公众号</li></ul><h2 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h2><p>我发文章的几个地方，欢迎大家在朋友圈等地方分享，多多交流。</p><ul><li>微信公众号：诸葛说talk</li><li>知乎：<a href="https://www.zhihu.com/people/richard-zhu/posts">https://www.zhihu.com/people/richard-zhu/posts</a></li><li>博客：<a href="https://rchardzhu.github.io/">https://rchardzhu.github.io/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近很多人在咨询 SKA 框架的情况，整理了一些资料，欢迎交流沟通~&lt;/p&gt;
&lt;h2 id=&quot;1-什么是SKAdNetwork？&quot;&gt;&lt;a href=&quot;#1-什么是SKAdNetwork？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是SKAdNetwor</summary>
      
    
    
    
    <category term="ads" scheme="https://rchardzhu.github.io/categories/ads/"/>
    
    
    <category term="ios" scheme="https://rchardzhu.github.io/tags/ios/"/>
    
    <category term="skadnetwork" scheme="https://rchardzhu.github.io/tags/skadnetwork/"/>
    
    <category term="ads" scheme="https://rchardzhu.github.io/tags/ads/"/>
    
  </entry>
  
  <entry>
    <title>backtrader入门</title>
    <link href="https://rchardzhu.github.io/2022/04/03/start-to-learn-backtrader/"/>
    <id>https://rchardzhu.github.io/2022/04/03/start-to-learn-backtrader/</id>
    <published>2022-04-03T10:00:00.000Z</published>
    <updated>2022-04-05T05:36:46.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p><a href="https://www.backtrader.com/">backtrader</a> 是一个用于回测和交易的python框架，它功能丰富，可以让你聚焦在设计可重用的交易策略、指标和分析上，而不用花大量时间在构建基础框架上面。</p><p>优点：</p><ul><li>github开源，策略编写简单快速</li><li>安装方便，除了matplotlib外，不依赖其他外部lib</li><li>支持ib等券商实时交易</li><li>数据来源支持csv文件，在线数据源或pandas格式，同时支持多数据来源、多策略</li><li>支持TA-lib指标，方便支持自定义指标的开发，集成pyfolio分析模块等</li><li>支持品种多，运行速度快：pandas 矢量运算、多策略并行运算</li></ul><p>缺点：</p><ul><li>gpl 3.0授权，更改框架需要开源</li><li>画图界面风格比较老旧</li><li>框架代码抽象比较多，使用了大量的元编程，学习比较费劲</li></ul><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install backtrader</span><br><span class="line">git clone https://github.com/mementum/backtrader.git</span><br><span class="line">cd samples/commission-schemes</span><br><span class="line">python commission-schemes.py --plot</span><br></pre></td></tr></table></figure><p>出现如下提示&amp;图形，表明安装正常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2006-03-09, BUY CREATE, 3757.59</span><br><span class="line">2006-03-10, BUY EXECUTED, Price: 3754.13, Cost: 2000.00, Comm 2.00</span><br><span class="line">2006-04-11, SELL CREATE, 3788.81</span><br><span class="line">2006-04-12, SELL EXECUTED, Price: 3786.93, Cost: 2000.00, Comm 2.00</span><br><span class="line">2006-04-12, TRADE PROFIT, GROSS 328.00, NET 324.00</span><br><span class="line">2006-04-20, BUY CREATE, 3860.00</span><br><span class="line">2006-04-21, BUY EXECUTED, Price: 3863.57, Cost: 2000.00, Comm 2.00</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><p><img src="https://pic3.zhimg.com/80/v2-f4bf28c51047d506cf68cc4f4cb7491e_720w.jpg" alt="图形"><br>如果出现如下错误，说明matplotlib安装不对，<code>ImportError: cannot import name &#39;warnings&#39; from &#39;matplotlib.dates&#39;</code><br>解决办法：<code>pip install matplotlib==3.2.2  -i https://pypi.tuna.tsinghua.edu.cn/simple</code></p><h2 id="3-代码框架介绍"><a href="#3-代码框架介绍" class="headerlink" title="3. 代码框架介绍"></a>3. 代码框架介绍</h2><p>backtrader代码运行主要包括以下组成部分：</p><ol><li>Strategy交易策略模块：需要设计交易策略，根据信号进行买入/卖出</li></ol><ul><li>设计策略中用于生成交易信号的指标</li><li>编写买入、卖出的交易逻辑</li><li>按需打印交易信息</li></ul><ol start="2"><li>DataFeeds数据模块: 将目标金融数据加载到回测框架中</li><li>Cerebro回测框架设置：根据需要设置初始资金，佣金，数据来源，交易策略，交易头寸大小。通过Broker经纪商模块设置</li><li>运行回测：运行Cerebro回测并打印出所有已执行的交易</li><li>按需添加策略分析指标Analyzers或观测器Observers评估效果： 以图形和风险收益等指标对交易策略的回测结果进行评价</li></ol><p>Lines说明：Lines是backtrader回测的数据，由一系列的点组成，通常包括以下类别的数据：Open（开盘价）, High（最高价）, Low（最低价）, Close（收盘价）, Volume（成交量）, OpenInterest（未平仓量，没有的话设置为0）。Data Feeds（数据加载）、Indicators（技术指标）和Strategies（策略）都会生成 Lines。价格数据中的所有”Open” (开盘价)按时间组成一条 Line。所以，一组含有以上6个类别的价格数据，共有6条 Lines。如果算上“DateTime”（时间，可以看作是一组数据的主键），一共有7条 Lines。当访问一条 Line 的数据时，会默认指向下标为 0 的数据，用于访问当前时刻。backtrader会将”0”一直指向当前值，下标 -1 来访问上一个值。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.dataclose[0] # 当日的收盘价</span><br><span class="line">self.dataclose[-1] # 昨天的收盘价</span><br><span class="line">self.dataclose[-2] # 前天的收盘价</span><br></pre></td></tr></table></figure><p>其他说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.sma5 = bt.indicators.SimpleMovingAverage(</span><br><span class="line">            self.datas[0], period=5)    # 返回MA5的相关数据</span><br><span class="line">            </span><br><span class="line">cerebro.broker.setcash(100000.0)    # 设定初始资金    </span><br><span class="line">cerebro.broker.setcommission(0.005) # 每次交易都需要支付一定的佣金</span><br><span class="line">cerebro.broker.getvalue() # 目前的资金</span><br><span class="line">cerebro.addsizer(bt.sizers.FixedSize, stake=100) # 设定每次交易买入的股数</span><br></pre></td></tr></table></figure><p>以commission-schemes.py为例进行说明，代码如下，对应位置加上了注释说明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">import argparse </span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"># 导入backtrader相关包</span><br><span class="line">import backtrader as bt</span><br><span class="line">import backtrader.feeds as btfeeds</span><br><span class="line">import backtrader.indicators as btind</span><br><span class="line"></span><br><span class="line"># 交易策略</span><br><span class="line">class SMACrossOver(bt.Strategy):  </span><br><span class="line">    params = (</span><br><span class="line">        (&#x27;stake&#x27;, 1),    # 交易股数</span><br><span class="line">        (&#x27;period&#x27;, 30),  # 周期长度</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    def log(self, txt, dt=None):</span><br><span class="line">        &#x27;&#x27;&#x27; Logging function fot this strategy&#x27;&#x27;&#x27;</span><br><span class="line">        dt = dt or self.datas[0].datetime.date(0)</span><br><span class="line">        print(&#x27;%s, %s&#x27; % (dt.isoformat(), txt))</span><br><span class="line"></span><br><span class="line">    # 打印订单信息，可选</span><br><span class="line">    def notify_order(self, order):</span><br><span class="line">        if order.status in [order.Submitted, order.Accepted]:</span><br><span class="line">            # Buy/Sell order submitted/accepted to/by broker - Nothing to do</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        # Check if an order has been completed</span><br><span class="line">        # Attention: broker could reject order if not enougth cash</span><br><span class="line">        if order.status in [order.Completed, order.Canceled, order.Margin]:</span><br><span class="line">            if order.isbuy():</span><br><span class="line">                self.log(</span><br><span class="line">                    &#x27;BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f&#x27; %</span><br><span class="line">                    (order.executed.price,</span><br><span class="line">                     order.executed.value,</span><br><span class="line">                     order.executed.comm))</span><br><span class="line">            else:  # Sell</span><br><span class="line">                self.log(&#x27;SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f&#x27; %</span><br><span class="line">                         (order.executed.price,</span><br><span class="line">                          order.executed.value,</span><br><span class="line">                          order.executed.comm))</span><br><span class="line">    </span><br><span class="line">    # 打印交易信息，可选</span><br><span class="line">    def notify_trade(self, trade):</span><br><span class="line">        if trade.isclosed:</span><br><span class="line">            self.log(&#x27;TRADE PROFIT, GROSS %.2f, NET %.2f&#x27; %</span><br><span class="line">                     (trade.pnl, trade.pnlcomm))</span><br><span class="line"></span><br><span class="line">    # 初始化策略属性、指标，必须</span><br><span class="line">    def __init__(self):</span><br><span class="line">        sma = btind.SMA(self.data, period=self.p.period)</span><br><span class="line">        # &gt; 0 crossing up / &lt; 0 crossing down</span><br><span class="line">        self.buysell_sig = btind.CrossOver(self.data, sma)</span><br><span class="line"></span><br><span class="line">    # 交易逻辑实现，必须</span><br><span class="line">    def next(self):</span><br><span class="line">        if self.buysell_sig &gt; 0:</span><br><span class="line">            self.log(&#x27;BUY CREATE, %.2f&#x27; % self.data.close[0])</span><br><span class="line">            self.buy(size=self.p.stake)  # keep order ref to avoid 2nd orders</span><br><span class="line"></span><br><span class="line">        elif self.position and self.buysell_sig &lt; 0:</span><br><span class="line">            self.log(&#x27;SELL CREATE, %.2f&#x27; % self.data.close[0])</span><br><span class="line">            self.sell(size=self.p.stake)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def runstrategy():</span><br><span class="line">    args = parse_args()</span><br><span class="line"></span><br><span class="line">    # 实例化cerebro</span><br><span class="line">    cerebro = bt.Cerebro()</span><br><span class="line"></span><br><span class="line">    # Get the dates from the args</span><br><span class="line">    fromdate = datetime.datetime.strptime(args.fromdate, &#x27;%Y-%m-%d&#x27;)</span><br><span class="line">    todate = datetime.datetime.strptime(args.todate, &#x27;%Y-%m-%d&#x27;)</span><br><span class="line"></span><br><span class="line">    # 从csv文件读取数据</span><br><span class="line">    data = btfeeds.BacktraderCSVData(</span><br><span class="line">        dataname=args.data,</span><br><span class="line">        fromdate=fromdate,</span><br><span class="line">        todate=todate)</span><br><span class="line"></span><br><span class="line">    # 将数据传给cerebro</span><br><span class="line">    cerebro.adddata(data)</span><br><span class="line"></span><br><span class="line">    # 添加策略</span><br><span class="line">    cerebro.addstrategy(SMACrossOver, period=args.period, stake=args.stake)</span><br><span class="line"></span><br><span class="line">    # 设置初始资金</span><br><span class="line">    cerebro.broker.setcash(args.cash)</span><br><span class="line"></span><br><span class="line">    commtypes = dict(</span><br><span class="line">        none=None,</span><br><span class="line">        perc=bt.CommInfoBase.COMM_PERC,</span><br><span class="line">        fixed=bt.CommInfoBase.COMM_FIXED)</span><br><span class="line"></span><br><span class="line">    # 设置交易佣金</span><br><span class="line">    cerebro.broker.setcommission(commission=args.comm,</span><br><span class="line">                                 mult=args.mult,</span><br><span class="line">                                 margin=args.margin,</span><br><span class="line">                                 percabs=not args.percrel,</span><br><span class="line">                                 commtype=commtypes[args.commtype],</span><br><span class="line">                                 stocklike=args.stocklike)</span><br><span class="line"></span><br><span class="line">    # 启动回测</span><br><span class="line">    cerebro.run()</span><br><span class="line"></span><br><span class="line">    # 绘图</span><br><span class="line">    if args.plot:</span><br><span class="line">        cerebro.plot(numfigs=args.numfigs, volume=False)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 从命令行解析参数</span><br><span class="line">def parse_args():</span><br><span class="line">    parser = argparse.ArgumentParser(</span><br><span class="line">        description=&#x27;Commission schemes&#x27;,</span><br><span class="line">        formatter_class=argparse.ArgumentDefaultsHelpFormatter,)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(&#x27;--data&#x27;, &#x27;-d&#x27;,</span><br><span class="line">                        default=&#x27;../../datas/2006-day-001.txt&#x27;,</span><br><span class="line">                        help=&#x27;data to add to the system&#x27;)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(&#x27;--fromdate&#x27;, &#x27;-f&#x27;,</span><br><span class="line">                        default=&#x27;2006-01-01&#x27;,</span><br><span class="line">                        help=&#x27;Starting date in YYYY-MM-DD format&#x27;)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(&#x27;--todate&#x27;, &#x27;-t&#x27;,</span><br><span class="line">                        default=&#x27;2006-12-31&#x27;,</span><br><span class="line">                        help=&#x27;Starting date in YYYY-MM-DD format&#x27;)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(&#x27;--stake&#x27;, default=1, type=int,</span><br><span class="line">                        help=&#x27;Stake to apply in each operation&#x27;)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(&#x27;--period&#x27;, default=30, type=int,</span><br><span class="line">                        help=&#x27;Period to apply to the Simple Moving Average&#x27;)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(&#x27;--cash&#x27;, default=10000.0, type=float,</span><br><span class="line">                        help=&#x27;Starting Cash&#x27;)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(&#x27;--comm&#x27;, default=2.0, type=float,</span><br><span class="line">                        help=(&#x27;Commission factor for operation, either a&#x27;</span><br><span class="line">                              &#x27;percentage or a per stake unit absolute value&#x27;))</span><br><span class="line"></span><br><span class="line">    parser.add_argument(&#x27;--mult&#x27;, default=10, type=int,</span><br><span class="line">                        help=&#x27;Multiplier for operations calculation&#x27;)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(&#x27;--margin&#x27;, default=2000.0, type=float,</span><br><span class="line">                        help=&#x27;Margin for futures-like operations&#x27;)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(&#x27;--commtype&#x27;, required=False, default=&#x27;none&#x27;,</span><br><span class="line">                        choices=[&#x27;none&#x27;, &#x27;perc&#x27;, &#x27;fixed&#x27;],</span><br><span class="line">                        help=(&#x27;Commission - choose none for the old&#x27;</span><br><span class="line">                              &#x27; CommissionInfo behavior&#x27;))</span><br><span class="line"></span><br><span class="line">    parser.add_argument(&#x27;--stocklike&#x27;, required=False, action=&#x27;store_true&#x27;,</span><br><span class="line">                        help=(&#x27;If the operation is for stock-like assets or&#x27;</span><br><span class="line">                              &#x27;future-like assets&#x27;))</span><br><span class="line"></span><br><span class="line">    parser.add_argument(&#x27;--percrel&#x27;, required=False, action=&#x27;store_true&#x27;,</span><br><span class="line">                        help=(&#x27;If perc is expressed in relative xx% rather&#x27;</span><br><span class="line">                              &#x27;than absolute value 0.xx&#x27;))</span><br><span class="line"></span><br><span class="line">    # -p或--plot 需要画图</span><br><span class="line">    parser.add_argument(&#x27;--plot&#x27;, &#x27;-p&#x27;, action=&#x27;store_true&#x27;,</span><br><span class="line">                        help=&#x27;Plot the read data&#x27;)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(&#x27;--numfigs&#x27;, &#x27;-n&#x27;, default=1,</span><br><span class="line">                        help=&#x27;Plot using numfigs figures&#x27;)</span><br><span class="line"></span><br><span class="line">    return parser.parse_args()</span><br><span class="line"></span><br><span class="line"># 主函数</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    runstrategy()</span><br></pre></td></tr></table></figure><h2 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h2><p>以下是发文章的几个地方。欢迎关注微信公众号，最新的文章会优先发布在微信公众号上。</p><ul><li>微信公众号：诸葛说talk</li><li>知乎：<a href="https://www.zhihu.com/people/richard-zhu/posts">https://www.zhihu.com/people/richard-zhu/posts</a></li><li>博客：<a href="https://rchardzhu.github.io/">https://rchardzhu.github.io/</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/mementum/backtrader">backtrader github</a></li><li><a href="https://www.backtrader.com/docu/">backtrader官方文档</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.backtrader.com/&quot;&gt;backtrader&lt;/a&gt; 是一个用于回测</summary>
      
    
    
    
    <category term="quant" scheme="https://rchardzhu.github.io/categories/quant/"/>
    
    <category term="python" scheme="https://rchardzhu.github.io/categories/python/"/>
    
    
    <category term="quant" scheme="https://rchardzhu.github.io/tags/quant/"/>
    
    <category term="backtrader" scheme="https://rchardzhu.github.io/tags/backtrader/"/>
    
    <category term="python" scheme="https://rchardzhu.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>rqalpha入门</title>
    <link href="https://rchardzhu.github.io/2022/03/26/start-to-learn-rqalpha/"/>
    <id>https://rchardzhu.github.io/2022/03/26/start-to-learn-rqalpha/</id>
    <published>2022-03-26T14:00:00.000Z</published>
    <updated>2022-03-27T01:22:38.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="rqalpha简介"><a href="#rqalpha简介" class="headerlink" title="rqalpha简介"></a>rqalpha简介</h2><ul><li><a href="https://github.com/ricequant/rqalpha">rqalpha</a>是<a href="https://www.ricequant.com/welcome/">米筐量化</a>开源的从数据获取、算法交易、回测引擎、实盘模拟、实盘交易到数据分析的程序化交易框架。跟quantopian开源的<a href="https://github.com/quantopian/zipline">zipline</a>从api到本地运行方式都比较类似</li></ul><p>优点：</p><ul><li>rqalpha简单易学，能很快上手</li><li>rqalpha具有灵活的配置方式和比较强大的扩展性，可以比较容易地定制</li><li>rqalpha所有的策略都可以直接在 <a href="https://www.ricequant.com/welcome/">Ricequant</a>上进行回测和实盘模拟，并且可以通过微信和邮件实时推送交易信号</li></ul><p>缺点：</p><ul><li>rqalpha不支持港美股回测&amp;交易，可以自定义支持，但成本不小</li><li>rqalpha仅限非商业使用，如需商业使用，需要联系官方</li><li>Ricequant实盘模拟需要开通企业版</li><li>rqalpha本身支持不同周期的回测和实盘交易，但是目前只免费开放A股市场日线数据，如果用户需要做分钟回测或者更细级别的回测可以在 Ricequant上进行，也通过实现数据层接口函数来使用自己的数据</li></ul><h2 id="rqalpha安装"><a href="#rqalpha安装" class="headerlink" title="rqalpha安装"></a>rqalpha安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install rqalpha</span><br></pre></td></tr></table></figure><p>RiceQuant免费提供日级别的股票、常用指数、场内基金和期货数据供回测使用。数据每个月月初更新，可以通过以下命令来下载和更新:<br><code>$ rqalpha download-bundle</code><br>bundle 默认存放在 ~/.rqalpha 下，也可以指定 bundle 的存放位置<br><code>$ rqalpha download-bundle -d target_bundle_path</code><br>如果使用了指定路径来存放 bundle，那么执行程序的时候也同样需要指定对应的 bundle 路径。<br><code>$ rqalpha run -d target_bundle_path .....</code></p><p>如果申请了免费试用（免费试用15天，试用账户进行了每天 50MB 的配额限制，<a href="https://www.ricequant.com/welcome/purchase#1">申请链接</a>）或者付费购买了米筐数据服务，可以使用 RQDatac 在每日盘后即时更新回测数据，更新命令如下：<br><code>$ rqalpha update-bundle</code></p><ul><li><p>运行以下命令，将会在指定目录生成一个examples文件夹，其中包含几个有趣的样例策略:<br><code>$ rqalpha examples -d ./</code></p></li><li><p>运行回测</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd examples</span><br><span class="line">$ rqalpha run -f rsi.py -s 2020-01-01 -e 2021-01-01 -o result.pkl --plot --progress --account stock 100000</span><br></pre></td></tr></table></figure></li><li><p>绘制回测结果：如果运行完回测后，还需要再次绘制回测结果，可以运行以下命令:<br><code>$ rqalpha plot result.pkl</code></p></li></ul><h2 id="rqalpha使用"><a href="#rqalpha使用" class="headerlink" title="rqalpha使用"></a>rqalpha使用</h2><p>rqalpha抽离了策略框架的所有技术细节，以API的方式提供给策略研发者用于编写策略，从而避免陷入过多的技术细节。</p><p>rqalpha的 API主要分为约定函数、数据查询接口、交易接口等几类。</p><ol><li><p>约定函数: 作为 API 的入口函数，用户必须实现对应的约定函数才可以正确的使用RQAlpha</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* init() : 初始化方法，会在程序启动的时候执行</span><br><span class="line">* handle_bar(): bar数据更新时会自动触发调用</span><br><span class="line">* before_trading(): 会在每天策略交易开始前调用</span><br><span class="line">* after_trading(): 会在每天交易结束后调用</span><br></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 在这个方法中编写任何的初始化逻辑。context对象将会在你的算法策略的任何方法之间做传递。</span><br><span class="line">def init(context):</span><br><span class="line">    # 在context中保存全局变量</span><br><span class="line">    context.s1 = &quot;000001.XSHE&quot;</span><br><span class="line">    # 实时打印日志</span><br><span class="line">    logger.info(&quot;RunInfo: &#123;&#125;&quot;.format(context.run_info))</span><br><span class="line"></span><br><span class="line"># before_trading此函数会在每天策略交易开始前被调用，当天只会被调用一次</span><br><span class="line">def before_trading(context):</span><br><span class="line">    logger.info(&quot;开盘前执行before_trading函数&quot;)</span><br><span class="line"></span><br><span class="line"># 你选择的证券的数据更新将会触发此段逻辑，例如日或分钟历史数据切片或者是实时数据切片更新</span><br><span class="line">def handle_bar(context, bar_dict):</span><br><span class="line">    logger.info(&quot;每一个Bar执行&quot;)</span><br><span class="line">    logger.info(&quot;打印Bar数据：&quot;)</span><br><span class="line">    logger.info(bar_dict[context.s1])</span><br><span class="line"></span><br><span class="line"># after_trading函数会在每天交易结束后被调用，当天只会被调用一次</span><br><span class="line">def after_trading(context):</span><br><span class="line">    logger.info(&quot;收盘后执行after_trading函数&quot;)</span><br></pre></td></tr></table></figure></li><li><p>数据查询接口<br>需要获取数据，根据数据来确定我们的仓位逻辑，因此会使用到数据查询的 API接口。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* all_instruments() : 获取所有合约基础信息数据</span><br><span class="line">* instruments() : 获取合约详细数据</span><br><span class="line">* history_bars() : 获取某一合约的历史数据</span><br><span class="line">* current_snapshot() : 获取当前快照数据</span><br><span class="line">* get_future_contracts() : 获取期货可以交易合约列表</span><br><span class="line">* get_trading_dates(): 获取交易日列表</span><br><span class="line">* get_previous_trading_date() : 获取上一日交易日</span><br><span class="line">* get_next_trading_date() : 获取下一个交易日</span><br><span class="line">* get_yield_curve(): 获取收益率曲线</span><br><span class="line">* is_suspended() : 判断某股票当天是否停牌</span><br><span class="line">* is_st_stock() : 判断某股票是否为 *st</span><br></pre></td></tr></table></figure><ol start="3"><li>交易接口<br>rqalpha提供了多种交易接口，以方便不同的使用需求。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* order_shares(): 【股票专用】指定股数交易</span><br><span class="line">* order_lots(): 【股票专用】指定手数交易</span><br><span class="line">* order_value(): 【股票专用】指定价值交易</span><br><span class="line">* order_percent():【股票专用】 一定比例下单</span><br><span class="line">* order_target_value(): 【股票专用】按照目标价值下单</span><br><span class="line">* order_target_percent(): 【股票专用】按照目标比例下单</span><br><span class="line">* buy_open(): 【期货专用】买开</span><br><span class="line">* sell_close():【期货专用】 平买仓</span><br><span class="line">* sell_open(): 【期货专用】卖开</span><br><span class="line">* buy_close(): 【期货专用】平卖仓</span><br><span class="line">* cancel_order(): 撤单</span><br><span class="line">* get_open_orders(): 获取未成交订单数据</span><br></pre></td></tr></table></figure></li></ol><p>rsi.py示例代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">from rqalpha.apis import *</span><br><span class="line"></span><br><span class="line">import talib</span><br><span class="line"></span><br><span class="line"># 在这个方法中编写任何的初始化逻辑。context对象将会在你的算法策略的任何方法之间做传递。</span><br><span class="line">def init(context):</span><br><span class="line"></span><br><span class="line">    # 选择我们感兴趣的股票</span><br><span class="line">    context.s1 = &quot;000001.XSHE&quot;</span><br><span class="line">    context.s2 = &quot;601988.XSHG&quot;</span><br><span class="line">    context.s3 = &quot;000068.XSHE&quot;</span><br><span class="line">    context.stocks = [context.s1, context.s2, context.s3]</span><br><span class="line"></span><br><span class="line">    context.TIME_PERIOD = 14</span><br><span class="line">    context.HIGH_RSI = 85</span><br><span class="line">    context.LOW_RSI = 30</span><br><span class="line">    context.ORDER_PERCENT = 0.3</span><br><span class="line"></span><br><span class="line"># 你选择的证券的数据更新将会触发此段逻辑，例如日或分钟历史数据切片或者是实时数据切片更新</span><br><span class="line">def handle_bar(context, bar_dict):</span><br><span class="line">    # 开始编写你的主要的算法逻辑</span><br><span class="line"></span><br><span class="line">    # bar_dict[order_book_id] 可以拿到某个证券的bar信息</span><br><span class="line">    # context.portfolio 可以拿到现在的投资组合状态信息</span><br><span class="line"></span><br><span class="line">    # 使用order_shares(id_or_ins, amount)方法进行落单</span><br><span class="line"></span><br><span class="line">    # TODO: 开始编写你的算法吧！</span><br><span class="line"></span><br><span class="line">    # 对我们选中的股票集合进行loop，运算每一只股票的RSI数值</span><br><span class="line">    for stock in context.stocks:</span><br><span class="line">        # 读取历史数据</span><br><span class="line">        prices = history_bars(stock, context.TIME_PERIOD+1, &#x27;1d&#x27;, &#x27;close&#x27;)</span><br><span class="line"></span><br><span class="line">        # 用Talib计算RSI值</span><br><span class="line">        rsi_data = talib.RSI(prices, timeperiod=context.TIME_PERIOD)[-1]</span><br><span class="line"></span><br><span class="line">        cur_position = get_position(stock).quantity</span><br><span class="line">        # 用剩余现金的30%来购买新的股票</span><br><span class="line">        target_available_cash = context.portfolio.cash * context.ORDER_PERCENT</span><br><span class="line"></span><br><span class="line">        # 当RSI大于设置的上限阀值，清仓该股票</span><br><span class="line">        if rsi_data &gt; context.HIGH_RSI and cur_position &gt; 0:</span><br><span class="line">            order_target_value(stock, 0)</span><br><span class="line"></span><br><span class="line">        # 当RSI小于设置的下限阀值，用剩余cash的一定比例补仓该股</span><br><span class="line">        if rsi_data &lt; context.LOW_RSI:</span><br><span class="line">            logger.info(&quot;target available cash caled: &quot; + str(target_available_cash))</span><br><span class="line">            # 如果剩余的现金不够一手 - 100shares，那么会被ricequant 的order management system reject掉</span><br><span class="line">            order_value(stock, target_available_cash)</span><br></pre></td></tr></table></figure><h2 id="多种方式运行策略"><a href="#多种方式运行策略" class="headerlink" title="多种方式运行策略"></a>多种方式运行策略</h2><ul><li>命令行运行：rqalpha run -f rsi.py -s 2020-01-01 -e 2021-01-01 -o result.pkl –plot –progress –account stock 100000</li><li>使用配置文件运行策略： rqalpha在运行策略时候会在当前目录下寻找 config.yml 或者 config.json 文件作为用户配置文件来读取，可以创建config.yml 配置文件，里面配置项为strategy_file: .buy_and_hold.py</li><li>策略内配置参数信息</li><li>通过引用 rqalpha库在代码中运行策略：使用 run_file、run_code、 run_func函数来运行策略</li></ul><h2 id="创建mod"><a href="#创建mod" class="headerlink" title="创建mod"></a>创建mod</h2><p>rqalpha提供了拓展性较强的Mod Hook接口，这意味着开发者可以比较容易的对接第三方库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rqalpha mod list # 查看当前安装的 Mod 列表及状态</span><br><span class="line">$ rqalpha mod enable xxx # 启用</span><br><span class="line">$ rqalpha mod disable xxx # 关闭</span><br></pre></td></tr></table></figure><ul><li><p>扩展rqalpha API：如果你想为 rqalpha 创建自己的 API，可以通过 Mod 来注册新的 API。在内建的 mod 中，有一个 FuncatAPIMod，将通达信、同花顺的公式表达能力移植到python中，扩展了 rqalpha的 API</p></li><li><p>扩展rqalpha实现自有数据的读取：rqalpha不限制本地运行的策略调使用哪些库，因此可以直接在策略中读取文件、访问数据库等，但需要关注如下两个注意事项: </p><ul><li>请在 init, before_trading, handle_bar, handle_tick, after_trading 等函数中读取自有数据，而不要在函数外执行数据获取的代码，否则可能会产生异常。</li><li>rqalpha是读取策略代码并执行的，因此实际当前路径是运行 rqalpha 命令的路径，策略使用相对路径容易产生异常。如果您需要根据策略路径来定位相对路径可以通过context.config.base.strategy_file 来获取策略路径，从而获取相对策略文件的其他路径</li></ul></li><li><p>rqalpha采用logbook 作为默认的日志模块，可以通过在 mod 中为 logger添加 handler 实现自定义的日志收集</p></li></ul><p>诸葛说 基于rqalpha文档<a href="https://rqalpha.readthedocs.io/zh_CN/latest/development/data_source.html#tushare">行情数据 - 五十行代码接入 tushare 行情数据</a>完善了tushare mod接口，增加了对tspro接口的支持，参见<a href="https://github.com/rchardzhu/rqalpha_mod_tushare">rqalpha_mod_tushare</a></p><h2 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h2><p>我发文章的几个地方，欢迎大家在朋友圈等地方分享，多多交流。</p><ul><li>微信公众号：诸葛说talk</li><li>知乎：<a href="https://www.zhihu.com/people/richard-zhu/posts">https://www.zhihu.com/people/richard-zhu/posts</a></li><li>博客：<a href="https://rchardzhu.github.io/">https://rchardzhu.github.io/</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/ricequant/rqalpha">rqalpha github</a></li><li><a href="https://rqalpha.readthedocs.io/zh_CN/latest/intro/overview.html">rqalpha介绍</a></li><li><a href="https://www.zhihu.com/question/62256540">zipline和rqalpha对比</a></li><li><a href="https://rqalpha.readthedocs.io/zh_CN/latest/development/event_source.html#development-event-source">rqalpha扩展事件源</a></li><li><a href="https://rqalpha.readthedocs.io/zh_CN/latest/development/data_source.html">rqalpha扩展数据源</a></li><li><a href="https://rqalpha.readthedocs.io/zh_CN/latest/intro/examples.html">rqalpha策略示例</a></li><li><a href="https://rqalpha.readthedocs.io/zh_CN/latest/api/base_api.html">rqalpha基础api</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;rqalpha简介&quot;&gt;&lt;a href=&quot;#rqalpha简介&quot; class=&quot;headerlink&quot; title=&quot;rqalpha简介&quot;&gt;&lt;/a&gt;rqalpha简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ricequan</summary>
      
    
    
    
    <category term="quant" scheme="https://rchardzhu.github.io/categories/quant/"/>
    
    <category term="python" scheme="https://rchardzhu.github.io/categories/python/"/>
    
    
    <category term="quant" scheme="https://rchardzhu.github.io/tags/quant/"/>
    
    <category term="python" scheme="https://rchardzhu.github.io/tags/python/"/>
    
    <category term="rqalpha" scheme="https://rchardzhu.github.io/tags/rqalpha/"/>
    
  </entry>
  
  <entry>
    <title>vnpy/VeighNa入门</title>
    <link href="https://rchardzhu.github.io/2022/03/20/start-to-learn-vnpy-veighna/"/>
    <id>https://rchardzhu.github.io/2022/03/20/start-to-learn-vnpy-veighna/</id>
    <published>2022-03-20T02:00:00.000Z</published>
    <updated>2022-03-20T14:05:05.595Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><a href="https://github.com/vnpy/vnpy">VeighNa</a> – 基于Python的开源量化交易系统开发框架， 之前叫vnpy，最近改名叫VeighNa了，官网是 <a href="https://www.vnpy.com/">https://www.vnpy.com</a> , 对应的产品是VeighNa Studio。 不是 <a href="http://www.vnpy.cn/">http://www.vnpy.cn</a> ，其对应的产品是VN Trader 。百度搜vnpy出来的是<a href="https://www.vnpy.cn./">https://www.vnpy.cn。</a> 不要搞混了，这两之前在打官司。 VeighNa定位是量化交易平台，提供从交易API对接到策略自动交易的完整解决方案,对接了国内外诸多不同类型的金融市场：证券、期货、期权、外汇、数字货币等。有回测功能，但支持较弱。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>对windows支持较好，提供了<a href="https://download.vnpy.com/veighna-studio-3.0.0.exe">python发行版</a>，其内置了最新版的VeighNa框架以及VeighNa Station量化管理平台，无需手动安装。 对ubuntu支持其次，对mac支持最弱。</p><p>安装后，在<a href="https://www.vnpy.com/forum/">VeighNa社区论坛</a>注册获得VeighNa Station账号密码（论坛账号密码即是）</p><p>Mac安装：  bash install_osx.sh</p><p>mac在开始安装vn.py之前，需要先手动安装几个特殊的库，打开Terminal后执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install ta-lib  // 不安装这个，会提示talib/_ta_lib.c:601:10: fatal error: &#x27;ta-lib/ta_defs.h&#x27; file not found</span><br><span class="line">pip install TA-Lib</span><br></pre></td></tr></table></figure><p>talib，是Technical Analysis Library的简称，是一种广泛用在程序化交易中进行金融市场数据的技术分析的函数库。它提供了多种技术分析的函数，方便我们量化投资中编程工作</p><p>因为mac上不支持ctp接口，所以要注释掉ctp接口，否则运行会报错</p><h2 id="代码框架介绍"><a href="#代码框架介绍" class="headerlink" title="代码框架介绍"></a>代码框架介绍</h2><p>vnpy 之前几乎所有代码都在 <a href="https://github.com/vnpy/vnpy">https://github.com/vnpy/vnpy</a> 这个代码库中，但python很容易造成依赖包冲突，导致软件不能正常工作，从2.x某个版本起，vnpy开始分拆成N个代码库，好处是你只需要安装你需要的依赖，不容易造成依赖包冲突，不好的是拆的太细代码库太多了，维护起来较麻烦。</p><p>下面按如下顺序对vn.py各个功能进行说明：数据、存储、交易、回测、rpc、event、策略。</p><ol><li>对接各类数据服务的适配器接口</li></ol><ul><li><a href="https://github.com/vnpy/vnpy_tushare/blob/main/vnpy_tushare/tushare_datafeed.py">对接tushare</a>–tushare api参考<a href="https://tushare.pro/document/2?doc_id=109">tushare通用行情接口</a></li><li><a href="https://github.com/vnpy/vnpy_tqsdk">对接tqsdk</a></li><li><a href="https://www.github.com/vnpy/vnpy_rqdata">对接米筐RQData</a>–实现类: RqdataClient</li></ul><p>Demo: 从rqdata获取历史行情，操作步骤:<br>    1) 初始化rqdataClient<br>    2) 构造请求对象<br>    3) 从rqdata获取数据<br>    4) 将数据保存到本地数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from vnpy.trader.rqdata import RqdataClient</span><br><span class="line">from vnpy.trader.object import HistoryRequest</span><br><span class="line"></span><br><span class="line"># 初始化rqdataClient</span><br><span class="line">rqdata_client = RqdataClient()</span><br><span class="line">rqdata_client.init()</span><br><span class="line"></span><br><span class="line"># 构造请求对象</span><br><span class="line">history_req = HistoryRequest(</span><br><span class="line">    symbol=&#x27;C2105&#x27;,</span><br><span class="line">    exchange=Exchange(&#x27;DCE&#x27;),</span><br><span class="line">    start=datetime(2021,1,1),</span><br><span class="line">    end=datetime(2021,2,1),</span><br><span class="line">    interval=Interval.DAILY</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 从rqdata获取数据</span><br><span class="line">ret_data = rqdata_client.query_history(history_req)</span><br><span class="line"></span><br><span class="line">#将数据保存到本地数据库</span><br><span class="line">database_manager.save_bar_data(ret_data)</span><br></pre></td></tr></table></figure><ul><li><p><a href="https://www.github.com/vnpy/vnpy_datamanager">data_manager</a>：历史数据管理模块，通过树形目录查看数据库中已有的数据概况，选择任意时间段数据查看字段细节，支持CSV文件的数据导入和导出。<br>一句话概括:用好database_manager这个对象，提供了如下方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def load_bar_data( self, symbol: str, exchange: Exchange,  interval: Interval,  start: datetime, end: datetime) -&gt; List[BarData]</span><br><span class="line">def load_tick_data(self,  symbol: str, exchange: Exchange,  start: datetime,  end: datetime ) -&gt; List[TickData]:</span><br><span class="line">def get_bar_overview(self) -&gt; List[BarOverview]</span><br><span class="line">def delete_bar_data( self,  symbol: str,  exchange: Exchange, interval: Interval ) -&gt; int:</span><br><span class="line">def delete_tick_data(self,  symbol: str, exchange: Exchange ) -&gt; int:</span><br></pre></td></tr></table></figure></li><li><p><a href="https://www.github.com/vnpy/vnpy_datarecorder">data_recorder</a>：行情记录模块，基于图形界面进行配置，根据需求实时录制Tick或者K线行情到数据库中，用于策略回测或者实盘初始化</p></li></ul><ol start="2"><li>对接各类数据库的适配器接口<br>在量化中，研究策略和实盘交易，都离不开数据。如果要提升回测速度，那么就需要搭建本地数据库。<br>vn.py数据库结构：DbBarData表示K线数据表映射对象，对应数据库的db_bar_data集合；DbTickData表示TICK数据表映射对象，对应对应数据库的db_tick_data； DbBarOverview表示K线汇总数据表映射对象，对应数据库的db_bar_overview。<br>通过对象database_manager实现，该对象通过抽象工厂模式，根据实际情况调用具体的数据库实现类。相关类: BaseDatabase。 存入数据库database_manager.save_bar_data(bars);从csv导入，import_data_from_csv, output_data_to_csv；从RQData查询， download_bar_data。</li></ol><ul><li><a href="https://github.com/vnpy/vnpy_sqlite/blob/main/vnpy_sqlite/sqlite_database.py">对接sqlite</a></li></ul><p>–基于peewee开发的SQLite数据库接口，无需另外安装配置数据库软件。SqliteDatabase类继承自BaseDatabase</p><ul><li><p><a href="https://github.com/vnpy/vnpy_mysql/blob/main/vnpy_mysql/mysql_database.py">对接mysql</a>–基于peewee开发的MySQL数据库接口。MysqlDatabase类继承自BaseDatabase</p></li><li><p><a href="https://github.com/vnpy/vnpy_mongodb/blob/main/vnpy_mongodb/mongodb_database.py">对接mongodb</a>–基于pymongo开发的MongoDB数据库接口</p></li></ul><ol start="3"><li>vnpy.gateway覆盖国内外所有交易品种的交易接口<br>对应接口交易接口Gateway类的query_history函数，实现历史数据的下载</li></ol><ul><li><p><a href="https://github.com/vnpy/vnpy_futu/blob/main/vnpy_futu/futu_gateway.py">对接futu</a>–基于futu-api开发的富途证券港股、美股交易接口。使用时需要注意本接口只支持限价单。FutuGateway类继承自BaseGateway。参考<a href="https://openapi.futunn.com/futu-api-doc/ftapi/init.html">futu api文档</a>。适用于港美股、期权等</p></li><li><p><a href="https://github.com/vnpy/vnpy_ib/blob/main/vnpy_ib/ib_gateway.py">对接ib</a>–封装InteractiveBrokers交易接口，connect, close, subscribe, send_order, query_account, query_position, query_history，底层使用EClient接口。适用于全球证券、期货、期权、贵金属等</p></li><li><p><a href="https://github.com/vnpy/vnpy_ctp">对接ctp</a>–基于CTP期货版的6.5.1接口封装开发，接口中自带的是【穿透式实盘环境】的dll文件。适用于国内期货、期权</p></li><li><p><a href="https://github.com/vnpy/vnpy_xtp">对接中泰XTP</a>–适用于国内证券（A股）、ETF期权</p></li><li><p>RPC服务（rpc）：跨进程通讯接口，用于分布式架构。 <a href="https://github.com/vnpy/vnpy/blob/master/vnpy/app/rpc_service/engine.py">使用zmq进行消息传递</a></p></li></ul><ol start="4"><li>回测</li></ol><ul><li><a href="https://www.github.com/vnpy/vnpy_ctabacktester">cta_backtester</a>：CTA策略回测模块，无需使用Jupyter Notebook，直接使用图形界面直接进行策略回测分析、参数优化等相关工作<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">backtester_engine.start_downloading(</span><br><span class="line">            vt_symbol,</span><br><span class="line">            interval,</span><br><span class="line">            start,</span><br><span class="line">            end</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>BacktesterEngine 封装了BacktestingEngine，还有init_rqdata。ib有query_history()，futu, tiger没有该接口</li></ul><ol start="5"><li>rpc &amp; webtrader</li></ol><ul><li><p><a href="https://www.github.com/vnpy/vnpy_webtrader">web_trader</a>：Web服务模块，针对B-S架构需求设计，实现了提供主动函数调用（REST）和被动数据推送（Websocket）的Web服务器</p></li><li><p><a href="https://www.github.com/vnpy/vnpy_rpcservice">rpc_service</a>：RPC服务模块，允许将某一进程启动为服务端，作为统一的行情和交易路由通道，允许多客户端同时连接，实现多进程分布式系统</p></li></ul><ol start="6"><li>事件驱动引擎</li></ol><ul><li><a href="https://github.com/vnpy/vnpy/blob/master/vnpy/event/engine.py">event</a>作为事件驱动型交易程序的核心，使用Queue和Timer来实现</li></ul><ol start="7"><li>开箱即用的各类量化策略交易应用（app）：</li></ol><ul><li><p><a href="https://www.github.com/vnpy/vnpy_ctastrategy">cta_strategy</a>：CTA策略引擎模块，在保持易用性的同时，允许用户针对CTA类策略运行过程中委托的报撤行为进行细粒度控制（降低交易滑点、实现高频策略）</p></li><li><p><a href="https://www.github.com/vnpy/vnpy_spreadtrading">spread_trading</a>：价差交易模块，支持自定义价差，实时计算价差行情和持仓，支持半自动价差算法交易以及全自动价差策略交易两种模式</p></li><li><p><a href="https://www.github.com/vnpy/vnpy_optionmaster">option_master</a>：期权交易模块，针对国内期权市场设计，支持多种期权定价模型、隐含波动率曲面计算、希腊值风险跟踪等功能</p></li><li><p><a href="https://www.github.com/vnpy/vnpy_portfoliostrategy">portfolio_strategy</a>：组合策略模块，面向同时交易多合约的量化策略（Alpha、期权套利等），提供历史数据回测和实盘自动交易功能</p></li><li><p><a href="https://www.github.com/vnpy/vnpy_algotrading">algo_trading</a>：算法交易模块，提供多种常用的智能交易算法：TWAP、Sniper、Iceberg、BestLimit等</p></li><li><p><a href="https://www.github.com/vnpy/vnpy_scripttrader">script_trader</a>：脚本策略模块，针对多标的组合类交易策略设计，同时也可以直接在命令行中实现REPL指令形式的交易，不支持回测功能</p></li><li><p><a href="https://www.github.com/vnpy/vnpy_paperaccount">paper_account</a>：本地仿真模块，纯本地化实现的仿真模拟交易功能，基于交易接口获取的实时行情进行委托撮合，提供委托成交推送以及持仓记录</p></li><li><p><a href="https://www.github.com/vnpy/vnpy_chartwizard">chart_wizard</a>：K线图表模块，基于RQData数据服务（期货）或者交易接口获取历史数据，并结合Tick推送显示实时行情变化</p></li><li><p><a href="https://www.github.com/vnpy/vnpy_portfoliomanager">portfolio_manager</a>：交易组合管理模块，以独立的策略交易组合（子账户）为基础，提供委托成交记录管理、交易仓位自动跟踪以及每日盈亏实时统计功能</p></li><li><p><a href="https://www.github.com/vnpy/vnpy_excelrtd">excel_rtd</a>：Excel RTD（Real Time Data）实时数据服务，基于pyxll模块实现在Excel中获取各类数据（行情、合约、持仓等）的实时推送更新</p></li><li><p><a href="https://www.github.com/vnpy/vnpy_riskmanager">risk_manager</a>：风险管理模块，提供包括交易流控、下单数量、活动委托、撤单总数等规则的统计和限制，有效实现前端风控功能</p></li></ul><h2 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h2><p>我发文章的几个地方，欢迎大家在朋友圈等地方分享，多多交流。</p><ul><li>微信公众号：诸葛说talk</li><li>知乎：<a href="https://www.zhihu.com/people/richard-zhu/posts">https://www.zhihu.com/people/richard-zhu/posts</a></li><li>博客：<a href="https://rchardzhu.github.io/">https://rchardzhu.github.io/</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/vnpy/vnpy">vnpy</a></li><li><a href="https://www.vnpy.com/docs/cn/index.html">vnpy项目文档</a></li><li><a href="https://zhuanlan.zhihu.com/vn-py">Veighna量化</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/vnpy/vnpy&quot;&gt;VeighNa&lt;/a&gt; – 基于Python的开源</summary>
      
    
    
    
    <category term="quant" scheme="https://rchardzhu.github.io/categories/quant/"/>
    
    <category term="python" scheme="https://rchardzhu.github.io/categories/python/"/>
    
    
    <category term="quant" scheme="https://rchardzhu.github.io/tags/quant/"/>
    
    <category term="python" scheme="https://rchardzhu.github.io/tags/python/"/>
    
    <category term="vnpy" scheme="https://rchardzhu.github.io/tags/vnpy/"/>
    
  </entry>
  
  <entry>
    <title>python gui与pyside</title>
    <link href="https://rchardzhu.github.io/2022/03/13/python-gui-and-pyside-md/"/>
    <id>https://rchardzhu.github.io/2022/03/13/python-gui-and-pyside-md/</id>
    <published>2022-03-13T01:52:00.000Z</published>
    <updated>2022-03-13T06:02:55.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><a href="https://docs.python.org/3/library/tkinter.html">Tkinter</a> – Tcl/Tk的python接口，python标准库自带不需单独安装。但界面相对简陋，基础组件不全，框架功能相对较弱，使用不多</li><li><a href="https://www.wxpython.org/">wxPython</a> – wxWidgets的python封装接口</li><li><a href="https://github.com/PySimpleGUI/PySimpleGUI">PySimpleGUI</a> – 对tkinter, Qt, WxPython等python gui框架的进一步封装</li><li><a href="https://riverbankcomputing.com/software/pyqt/intro">PyQt</a> –  Riverbank Computing公司发布的对QT框架的python封装，GPL授权</li><li><a href="https://wiki.qt.io/Qt_for_Python">PySide</a> – QT官方发布的QT python封装，LGPL授权，可以闭源发布。 qt官方给出的<a href="https://wiki.qt.io/Differences_Between_PySide_and_PyQt">Pyside和PyQt差异</a>，除了包名、工具名外，大部分差别不大</li></ul><p>从目前使用情况来看，PyQt使用的比较多，但PyQt是GPL授权，而PySide是LGPL授权，其功能与PyQt区别不大，但可以闭源发布。量化软件vnpy最新版使用的就是pyside6，下文主要介绍pyside6。</p><h2 id="pyside6介绍"><a href="#pyside6介绍" class="headerlink" title="pyside6介绍"></a>pyside6介绍</h2><ol><li>安装<br>安装前提：Python 3.6+。使用venv或conda创建一个新的python环境。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n qt python=3.8</span><br><span class="line">conda activate qt</span><br></pre></td></tr></table></figure>or <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m venv pyside</span><br><span class="line">source pyside/bin/activate</span><br></pre></td></tr></table></figure>然后使用pip安装pyside6 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install pyside6 # 安装最新版本</span><br><span class="line">pip install pyside6==6.0 # 安装6.0版本</span><br></pre></td></tr></table></figure>测试安装是否成功<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import PySide6.QtCore</span><br><span class="line">&gt;&gt;&gt; print(PySide6.__version__)</span><br><span class="line">6.2.1</span><br><span class="line">&gt;&gt;&gt; print(PySide6.QtCore.__version__)</span><br><span class="line">6.2.1</span><br></pre></td></tr></table></figure>除了pyside6 lib库安装好外，还安装了pyside6-designer、pyside6-uic、pyside6-rcc等工具。</li></ol><ul><li>pyside6-uic: 从.ui文件生成python代码，<code>pyside6-uic -i form.ui -o ui_form.py</code></li><li>pyside6-rcc： 从.qrc文件生成python代码，<code>pyside6-rcc -i resources.qrc -o rc_resources.py</code></li><li>pyside6-designer： Qt Designer对应的命令行程序，用于编辑/创建.ui文件</li></ul><ol start="2"><li>hello qt程序<br>将下列代码保存为hello_py.py，在终端运行python hello_py.py即可。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PySide6.QtWidgets import QApplication, QLabel</span><br><span class="line"></span><br><span class="line">app = QApplication(sys.argv)</span><br><span class="line">label = QLabel(&quot;Hello Qt for Python!&quot;)</span><br><span class="line">label.show()</span><br><span class="line">app.exec()</span><br></pre></td></tr></table></figure>说明：</li></ol><ul><li>QLabel是一个可以展示文本和图片的组件，文本可以是普通文本或富文本，比如html</li><li>QApplication app.exec()进入Qt主循环并且开始执行Qt代码</li></ul><ol start="3"><li>开发环境</li></ol><ul><li>vs code安装插件：Qt for Python</li><li>qt creator</li><li>pycharm配置外部工具</li></ul><ol start="4"><li>核心概念</li></ol><ul><li><p>Qt包括很多组件和模块，比如qtbase是一个包含很多模块的基础组件，它包含的module有：QtCore, QtGui, QtWidgets, QtNetwork等。所有这些module包含了很多你可以直接使用的类，比如QtCore里面包含了QFile, QTime, QByteArray等类。</p></li><li><p>QtWidgets是一个提供了很多预定义Widgets的模块，这些Widgets你可以添加到图形应用程序里面，包括Buttons, Labels, Boxes, Menus等。</p></li><li><p>QML提供了另外一种不同于Widgets的创建用户界面的方法，它首先的动机是应用于移动应用开发，但也可以在桌面应用开发中使用。QML跟Qt Quick模块一起，提供了使用点击、拖放、动画、过渡等与移动设备交互的方式。你可以在QML/Quick应用中找到的元素都聚焦于提供更现代的应用中</p></li></ul><p>Qt基本模块有三部分：</p><ul><li>QtCore: 提供了核心的非GUI功能，比如signal和slots，properties，序列化等</li><li>QtGui: 在GUI功能上扩展了QtCore的功能，比如：Events, windows and screens, OpenGL and raster-based 2D绘图，还有图片</li><li>QtWidgets: 提供了现成的组件，包括UI的图形元素</li></ul><p>QML and Qt Quick使用这些模块从python跟QML语言交互</p><ul><li>QtQML: 跟模块交互的基础python api</li><li>QtQuick: 在Qt应用中提供了类嵌入Qt Quick</li><li>QtQuickWidgets: 在基于widget的应用中提供了QQuickWidget类来前乳Qt Quick</li><li>Shiboken模块：使用python来扩展Qt/C++ 应用</li></ul><ol start="5"><li>Qt Widgets: </li></ol><ul><li>signals and slots: 用于QObject对象之间的通信。按钮点击时，click就是信号，槽位是当按钮被点击时发生的事情，比如关闭窗口，保存文件等。类似于其他的callback回调，但回调不是很自然</li><li>所有继承自QObject或它的子类的类(比如QWidget)都可以包含信号和槽位。当对象改变状态，且这个状态其他对象感兴趣时，对象可以发出信号</li><li>槽位可以用于接收信号，但他们也是普通成员函数。就像一个对象不知道是否有对象接收了它的信号一样，一个槽位也不知道是否有信号连接到它了。这确保了可以用Qt来创建真正独立的组件</li><li>一个槽位可以连接任意多的信号，一个信号也可以连接到任意多的槽位。连接一个信号到另外一个信号也是可能的</li><li>Qt widgets有许多预定义的信号和槽位，你可以创建继承自PySide6 widgets的任何类</li><li>Qt 自带的layout-support功能可以帮你在应用程序中组织widgets。QVBoxLayout用于垂直布局widgets，QTableWidget用于以表格形式展示信息, QTreeWidget，QTreeView用树的形式展示信息</li></ul><ol start="6"><li>使用ui文件</li></ol><ul><li><p>Qt Designer时一个图形UI设计工具，可以使用 Qt Designer基于Qt Widgets创建图形界面，它作为一个单独程序pyside6-designer或者嵌入到Qt Creator IDE。<a href="https://doc.qt.io/qtcreator/creator-using-qt-designer.html">Using Qt Designer</a>.设计存储在.ui文件中，是基于XML格式的文档. 可以使用pyside6-uic在编译时将设计转换成python/c++代码。</p></li><li><p>可以使用QtUiTools模块里面的类来直接加载ui文件</p></li><li><p><a href="https://doc.qt.io/qtforpython/tutorials/basictutorial/uifiles.html">从Designer或QtCreator用QUiLoader和pyside6-uic使用.ui文件</a></p></li></ul><ol start="7"><li>其他功能</li></ol><ul><li><p><a href="https://doc.qt.io/qtforpython/tutorials/basictutorial/qrcfiles.html">Using .qrc Files (pyside6-rcc)</a> – Qt资源系统是一个可以用来在应用程序中存储二进制文件的机制，这些文件可以嵌入到应用程序并且可以被QFile类和QIcon、QPixmap类的构造函数来访问，文件名用:/来开始。最常见的使用情况时自定义的图片、图标、字体等 </p></li><li><p>Qt Linguist和它相关的工具可以用来提供应用程序多语言的翻译功能，参考<a href="https://doc.qt.io/qtforpython/tutorials/basictutorial/translations.html">Translating Applications</a></p></li><li><p>Qt Widgets应用使用一个依赖于底层平台的默认主题。在某些情况，存在一些系统范围的配置可以用来修改Qt主题，也可以自己的widgets并为每个组件提供一个自定义的style. 参考<a href="https://doc.qt.io/qtforpython/tutorials/basictutorial/widgetstyling.html">Styling the Widgets Application</a></p></li><li><p>QML是一个声明式语言，可以让你比传统语言(c++)更快的开发应用程序。由于它的声明特性，非常适合设计应用程序的UI。在QML，一个用户界面被指定为带有属性的对象树</p></li><li><p>一个PySide6/QML应用程序由至少2个不同的文件组成–一个是QML描述的用户界面文件，另外一个是用于load QML文件的python文件。QtQml和QtQuick模块提供了基于QML的UI的必要功能</p></li><li><p>Shiboken 擅长Qt相关的binding生成，这意味着任何Qt/C++项目可以很容易暴露给python。另外，Shiboken也提供了对于非Qt的c++项目的支持</p></li></ul><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><ul><li><a href="https://doc.qt.io/qtforpython/tutorials/expenses/expenses.html">费用工具教程</a></li><li><a href="https://doc.qt.io/qtforpython/examples/index.html">更多pyside示例</a>–在pyside6安装环境site-packages/PySide6/examples目录下，包括3d、画图、多媒体、网络、数据可视化等多个分类</li><li><a href="https://github.com/vnpy/vnpy_ctabacktester/blob/main/vnpy_ctabacktester/ui/widget.py">vnpy qt</a></li></ul><h2 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h2><p>我发文章的几个地方，欢迎大家在朋友圈等地方分享，多多交流。</p><ul><li>微信公众号：诸葛说talk</li><li>知乎：<a href="https://www.zhihu.com/people/richard-zhu/posts">https://www.zhihu.com/people/richard-zhu/posts</a></li><li>博客：<a href="https://rchardzhu.github.io/">https://rchardzhu.github.io/</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.zhihu.com/question/32703639/answer/2311119286">为什么很多Python开发者写GUI不用Tkinter，而要选择PyQt和wxPython或其他？</a></li><li><a href="https://www.zhihu.com/question/306793447/answer/560109210">PyQt和PySide的历史渊源</a></li><li><a href="https://doc.qt.io/qtforpython/contents.html">Qt for Python官方完整教程</a></li><li><a href="https://doc.qt.io/qtforpython/quickstart.html">Qt for Python快速开始</a> – pyside6快速开始</li><li><a href="https://doc.qt.io/qtforpython/tutorials/pretutorial/whatisqt.html">pyside概念篇</a></li><li><a href="https://doc.qt.io/qtforpython/modules.html">pyside所有模块</a></li><li><a href="https://doc.qt.io/qtforpython/tutorials/index.html">pyside教程</a>–包括Qt Widgets、Quick/QML、General Applications基础教程</li><li><a href="https://doc.qt.io/qtforpython/tutorials/pretutorial/distribution.html">将应用程序分发到其他系统/平台</a> – 使用fbs、PyInstaller、cx_Freeze、briefcase、py2exe、Nuitka等工具打包python程序</li><li><a href="https://doc.qt.io/qt-6/model-view-programming.html">模型/视图编程</a></li><li><a href="https://build-system.fman.io/">fbs</a> – fbs解决了常见的打包和部署问题，基于Python和Qt, fbs是Electron的一个轻量级替代品</li><li><a href="https://www.electronjs.org/">electron</a> – 非python。使用 JavaScript，HTML 和 CSS 构建跨平台的桌面应用程序</li><li><a href="https://simulatedgreg.gitbooks.io/electron-vue/content/cn/">electron-vue</a> – 非python。 使用vue构建electron应用的模版项目</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.python.org/3/library/tkinter.html&quot;&gt;Tkinter</summary>
      
    
    
    
    <category term="python" scheme="https://rchardzhu.github.io/categories/python/"/>
    
    <category term="gui" scheme="https://rchardzhu.github.io/categories/gui/"/>
    
    
    <category term="python" scheme="https://rchardzhu.github.io/tags/python/"/>
    
    <category term="gui" scheme="https://rchardzhu.github.io/tags/gui/"/>
    
    <category term="pyside" scheme="https://rchardzhu.github.io/tags/pyside/"/>
    
  </entry>
  
  <entry>
    <title>使用basictex生成简历</title>
    <link href="https://rchardzhu.github.io/2022/02/27/using-latex-generate-resume-md/"/>
    <id>https://rchardzhu.github.io/2022/02/27/using-latex-generate-resume-md/</id>
    <published>2022-02-27T12:00:00.000Z</published>
    <updated>2022-02-27T12:10:21.121Z</updated>
    
    <content type="html"><![CDATA[<p>Latex 是功能非常强大的排版工具，<a href="https://www.tug.org/mactex/mactex-download.html">MacTeX 2021</a>有4Gb 大小，之前装过觉得用处不大，这次决定装一个mini版本<a href="https://www.tug.org/mactex/morepackages.html">BasicTex</a>，不用gui的话，功能也够用了</p><h2 id="安装basictex"><a href="#安装basictex" class="headerlink" title="安装basictex"></a>安装basictex</h2><p>从<a href="https://www.tug.org/mactex/morepackages.html">BasicTex</a> 官网手动下载pkg文件手动安装。或者使用homebrew安装。</p><p>使用 homebrew 安装非常简单，只需一条命令即可。</p><p><code>$brew install basictex</code><br>安装完还不能直接使用，还需要把 texlive 添加到环境变量中，才能找到相关的命令。</p><p><code>$export PATH=/usr/local/texlive/2021basic/bin/universal-darwin/:$PATH</code><br>执行<code>$xelatex</code>不报错的话，说明环境安装成功。<br>然后就是安装相关的包，以及更新包。</p><p><code>sudo tlmgr update --self</code><br>安装包的时候速度慢的话推荐使用<a href="https://mirror.tuna.tsinghua.edu.cn/help/CTAN/">清华的CTAN 镜像</a>。</p><h2 id="使用basictex生成简历"><a href="#使用basictex生成简历" class="headerlink" title="使用basictex生成简历"></a>使用basictex生成简历</h2><p>首先到网上找到喜欢的模板。比如： <a href="https://github.com/billryan/resume">billryan/resume</a> 或<a href="https://github.com/xdanaux/moderncv">xdanaux/moderncv</a>。</p><p>以billryan/resume 为例，git clone下载到本地后，使用git switch zh_CN 切换到中文分支。</p><p>执行： <code>$xelatex resume-zh_CN.tex</code></p><p>编译失败，会提示缺少某些包。使用tlmgr安装对应的包即可。</p><p>比如： <code>$sudo tlmgr install xifthen ifmtarg titlesec enumitem nth</code></p><p>安装完成后，继续xelatex编译即可，会生成resume-zh_CN.pdf 文件。</p><p>如果只是偶尔使用一下xelatex，也可以考虑试下xelatex云编译器 <a href="https://latexonline.cc/">cloud compiler LaTeX to PDF</a></p><h2 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h2><p>我发文章的几个地方，欢迎大家在朋友圈等地方分享，多多交流。</p><ul><li>微信公众号：诸葛说talk</li><li>知乎：<a href="https://www.zhihu.com/people/richard-zhu/posts">https://www.zhihu.com/people/richard-zhu/posts</a></li><li>博客：<a href="https://rchardzhu.github.io/">https://rchardzhu.github.io/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Latex 是功能非常强大的排版工具，&lt;a href=&quot;https://www.tug.org/mactex/mactex-download.html&quot;&gt;MacTeX 2021&lt;/a&gt;有4Gb 大小，之前装过觉得用处不大，这次决定装一个mini版本&lt;a href=&quot;http</summary>
      
    
    
    
    <category term="latex" scheme="https://rchardzhu.github.io/categories/latex/"/>
    
    <category term="tool" scheme="https://rchardzhu.github.io/categories/tool/"/>
    
    
    <category term="github" scheme="https://rchardzhu.github.io/tags/github/"/>
    
    <category term="latex" scheme="https://rchardzhu.github.io/tags/latex/"/>
    
    <category term="resume" scheme="https://rchardzhu.github.io/tags/resume/"/>
    
  </entry>
  
  <entry>
    <title>常用量化回测数据/收益指标的一些说明</title>
    <link href="https://rchardzhu.github.io/2022/02/06/common-invest-indicator-md/"/>
    <id>https://rchardzhu.github.io/2022/02/06/common-invest-indicator-md/</id>
    <published>2022-02-06T02:37:39.000Z</published>
    <updated>2022-02-06T02:53:27.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用数据-收益指标"><a href="#常用数据-收益指标" class="headerlink" title="常用数据/收益指标"></a>常用数据/收益指标</h2><ol><li>无风险利率(Risk-Free Rate)</li></ol><ul><li>无风险利率表示投资者在一定时间内能够期望从无任何风险的投资中获得的利率。现实中，通常使用伦敦同业拆放利率（London Inter bank Offered Rate，LIBOR）或美国国债利率作为无风险利率。因为一般认为金融机构倒闭的机会很低，财政有问题的银行会被禁止参与同业拆放，因此LIBOR是没有风险的。政府可以发行主权货币应付到期的债务，因此国债不可能违约。不过，此说法并不适用于欧元。欧元区国家无权发行货币，因此发生了欧洲主权债务危机</li></ul><ol start="2"><li>Cumulative Return &amp; 复合年均增长率(cagr：Compound Annual Growth Rate)</li></ol><ul><li>Cumulative Return：累计收益= (Ending Value/Beginning Value)</li><li>cagr计算方法为：总增长率百分比的n方根，n相等于有关时期内的年数。CAGR = (Ending Value/Beginning Value)^(1/# of years)－1</li></ul><ol start="3"><li>总杠杆(gross leverage)</li></ol><ul><li>总杠杆率是敞口绝对值的总和除以净资产（Net asset value,简称NAV），不考虑多空抵消和对冲。1亿美元标普500股票的长仓和1亿美元的标普500期货空仓总杠杆率为200%。这一指标反映的是总体投资活动水平，是交易对手风险和流动性风险的关注对象之一</li></ul><ol start="4"><li>最大回撤(Max Drawdown)</li></ol><ul><li>描述策略可能出现的最糟糕的情况，是指在某一段时期内产品净值从最高点开始回落到最低点的幅度。具体计算方法为：max(1 - 策略当日价值 / 当日之前产品最高净值)</li><li>举例说明：2010年7月20日初始净值1；恰逢2010年10月美国推出QE2全球股市大涨，该基金净值增长到1.8；其后国内股市剧烈震荡，截止2011年4月25，该基金净值为0.98.假设投资者在最高峰时期认购，半年后在最低潮时期赎回，亏损45.5%。这就是最大回撤率给高位追买的投资者的指示意义</li></ul><ol start="5"><li>波动率(Volatility)</li></ol><ul><li>是金融资产价格的波动程度，是对资产收益率不确定性的衡量，用于反映金融资产的风险水平。波动率越高，金融资产价格的波动越剧烈，资产收益率的不确定性就越强；波动率越低，金融资产价格的波动越平缓，资产收益率的确定性就越强。具体计算方法为：策略每日收益的年化标准差</li></ul><ol start="6"><li>胜率(win rate)</li></ol><ul><li>胜率的定义是赢钱次数除以总买入次数</li><li>举例说明：投入十次，七次盈利，三次亏损，胜率就是70%</li></ul><ol start="7"><li>胜负比(win loss ratio)</li></ol><ul><li>胜负比也称为“成功率”。赢/亏比率是赢的交易总数与输的交易数之比。它不考虑赢或输了多少钱，只考虑输赢次数</li></ul><ol start="8"><li>盈亏比(risk return ratio)</li></ol><ul><li>也叫赔率。指的是每次交易的盈利和亏损的比例，代表投资的风险收益比。投资系统的盈亏比=一段时间所有投资盈利单的盈利之和/相同时间段所有亏损单的亏损之和。投资的收益盈亏比是3是指平均来讲赚3块钱，要付出1块的止损。或者说冒一块钱的风险的一项投资获利了3块。长期来看，投资盈亏比，才是直接反映投资者综合水平的的一个量化指标</li><li>长期稳定赚大钱的成功者的系统，都是高盈亏比的系统。只有高盈亏比系统，才能成为成功者，才能算稳定盈利</li><li>举例说明：平均每次盈利30%，平均每次亏损10%，盈亏比就是3倍</li></ul><ol start="9"><li>阿尔法（alpha、α值）</li></ol><ul><li>投资者获得与市场波动无关的回报，也叫超额收益。 比如投资者获得了15%的回报，其基准获得了10%的回报，那么Alpha或者价值增值的部分就是5%</li></ul><ol start="10"><li>贝塔（beta、β值）</li></ol><ul><li>反映了策略对大盘变化的敏感性。例如一个策略的Beta为1.5，则大盘涨1%的时候，策略可能涨1.5%，反之亦然。具体计算方法为：策略每日收益与参考标准每日收益的协方差/参考标准每日收益的方差。</li><li>Beta coefficient = Covariance(R<del>e</del>, R<del>m</del>)/Variance(R<del>m</del>)<br>其中：R<del>e</del>为单一股票的回报， R<del>m</del>为整体市场的回报，Covariance为股票收益相对整体市场收益的变化情况， Variance为市场数据远离平均值的幅度</li></ul><ol start="11"><li>夏普比率(sharpe ratio)</li></ol><ul><li>夏普比率描述了资产收益对投资者所承担风险的补偿程度。当以一个相同基准来比较两种资产之时，夏普比率较高的资产在相同风险下收益更好；或者说，如果收益相同的话，夏普比率较高的资产风险较低。但是，像其他任何数学模型一样，它依赖于数据的正确性</li><li>sharpe ratio = (R<del>p</del> - R<del>f</del>)/$\sigma$<del>p</del><br>其中R<del>p</del>为投资组合的收益，R<del>f</del>为无风险资产的收益，sigma<del>p</del>为投资组合超额收益的标准方差</li></ul><ol start="12"><li>信息比例(information Ratio)</li></ol><ul><li>信息比率与夏普比率相似，主要区别在于夏普比率使用无风险收益(比如美国国债)作为基准，而信息比率使用风险指数作为基准（如标准普尔500指数）</li><li>具体计算方法为：(策略累积收益 - 基准累积收益)/策略与基准每日收益差值的标准差。【意义】：信息比率数值越大，业绩表现越好。它以马克维茨的均异模型为基础，可以衡量基金的均异特性，表示单位主动风险所带来的超额收益</li></ul><ol start="13"><li>索提比例（sortino ratio）</li></ol><ul><li>与夏普比率类似，所不同的是它区分了波动的好坏，因此在计算波动率时它所采用的不是标准差，而是下行标准差。这其中的隐含条件是投资组合的上涨（正回报率）符合投资人的需求，不应计入风险调整。具体计算方法为：(策略收益-无风险利率)/策略下行波动率。【适用范围】：因为索提诺比率使用的是下行偏差来考虑风险，那么所有的下行偏差局限性也会出现在索提诺比率中。也就是必须要有足够多的“不良”观测，才能计算一个有效的索提诺比率。sortino 比率数值越大，业绩表现越好。</li></ul><ol start="14"><li>卡玛比率(calmar ratio)</li></ol><ul><li>卡玛比率=超额收益/最大回撤(风险)</li><li>卡玛比率和卡玛比率的唯一不同之处就是分母不同，夏普比率使用标准差作为风险，卡玛比率使用最大回撤作为风险，本质上都是衡量基金的风险-回报关系</li></ul><ol start="15"><li>Omega比率（omega ratio）</li></ol><ul><li>omega比率实际上考虑了收益的整个分布信息，因此包括了所有高阶矩的信息。在临界收益率等于均值的时候，Omega比率等于1。在相同的临界收益率下，对于不同的投资选择，Omega比率越大越好。适用范围：在收益率不服从正态分布的时候，Omega是非常好的替代。【意义】：Omega比率值越高,投资绩效也就越好</li></ul><ol start="16"><li>Tail 比率（tail ratio）</li></ol><ul><li>日收益分布的95分位值/5分位值。【使用范围】：均值回归策略，这类型策略的最大风险在于左侧的尾部风险。单次的大额回撤需要很长的时间才能够恢复。因此 tail_ratio 很适合用来刻画这类策略面临的风险。【意义】：tail 比率越大越好，可以理解成衡量最好情况与最坏情况下的收益表现的指标。例如：tail_ratio = 0.25，5分位的亏损是95分位收益的四倍。 这样的策略在发生大额亏损的情况下很难在短时间内恢复</li></ul><ol start="17"><li>Common sense比率（common sense ratio）</li></ol><ul><li>(日收益分布的95分位值/5分位值) *(总盈利/总亏损）。【使用范围】：均值回归策略，趋势追踪策略。【意义】：大于1时，策略盈利；小于1时，策略亏损</li></ul><ol start="18"><li>skew值（Skewness）</li></ol><ul><li>亦称歪度，在概率论和统计学中衡量实数随机变量概率分布的不对称性。偏度的值可以为正，可以为负或者甚至是无法定义。在数量上，偏度为负（负偏态；左偏）就意味着在概率密度函数左侧的尾部比右侧的长，绝大多数的值（不一定包括中位数在内）位于平均值的右侧。偏度为正（正偏态；右偏）就意味着在概率密度函数右侧的尾部比左侧的长，绝大多数的值（不一定包括中位数）位于平均值的左侧。偏度为零就表示数值相对均匀地分布在平均值的两侧，但不一定意味着其为对称分布</li></ul><ol start="19"><li>峰度（kurtosis）</li></ol><ul><li>大于0表示收益的分布与正态分布相比较为陡峭</li></ul><ol start="20"><li>决定系数(coefficient of determination, R2)</li></ol><ul><li>累计对数收益对时间t的回归的R^2。【意义】：R平方值是趋势线拟合程度的指标，它的数值大小可以反映趋势线的估计值与对应的实际数据之间的拟合程度，拟合程度越高，趋势线的可靠性就越高。R平方值是取值范围在0～1之间的数值，也称为决定系数，最常用于评价回归模型优劣程度的指标</li></ul><h2 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h2><p>我发文章的几个地方，欢迎大家在朋友圈等地方分享，多多交流。</p><ul><li>微信公众号：诸葛说talk</li><li>知乎：<a href="https://www.zhihu.com/people/richard-zhu/posts">https://www.zhihu.com/people/richard-zhu/posts</a></li><li>博客：<a href="https://rchardzhu.github.io/">https://rchardzhu.github.io/</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>无风险利率: <a href="https://zh.wikipedia.org/wiki/%E6%97%A0%E9%A3%8E%E9%99%A9%E5%88%A9%E7%8E%87">wikipedia</a></li><li>cagr: <a href="https://www.investopedia.com/terms/c/cagr.asp">https://www.investopedia.com/terms/c/cagr.asp</a></li><li>波动率: <a href="http://abcexchange.io/terms/v/volatilityquotetrading.asp">http://abcexchange.io/terms/v/volatilityquotetrading.asp</a></li><li>胜负比: <a href="https://www.investopedia.com/terms/w/win-loss-ratio.asp">https://www.investopedia.com/terms/w/win-loss-ratio.asp</a></li><li>alpha: <a href="https://www.investopedia.com/terms/a/alpha.asp">https://www.investopedia.com/terms/a/alpha.asp</a></li><li>beta: <a href="https://www.investopedia.com/terms/b/beta.asp">https://www.investopedia.com/terms/b/beta.asp</a></li><li>sharpe: <a href="https://www.investopedia.com/terms/s/sharperatio.asp">https://www.investopedia.com/terms/s/sharperatio.asp</a></li><li>信息比例: <a href="https://www.investopedia.com/terms/i/informationratio.asp">https://www.investopedia.com/terms/i/informationratio.asp</a></li><li>sortino: <a href="https://www.investopedia.com/terms/s/sortinoratio.asp">https://www.investopedia.com/terms/s/sortinoratio.asp</a></li><li>calmar: <a href="https://www.investopedia.com/terms/c/calmarratio.asp">https://www.investopedia.com/terms/c/calmarratio.asp</a></li><li>skew: <a href="https://www.investopedia.com/terms/s/skewness.asp">https://www.investopedia.com/terms/s/skewness.asp</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常用数据-收益指标&quot;&gt;&lt;a href=&quot;#常用数据-收益指标&quot; class=&quot;headerlink&quot; title=&quot;常用数据/收益指标&quot;&gt;&lt;/a&gt;常用数据/收益指标&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;无风险利率(Risk-Free Rate)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul</summary>
      
    
    
    
    <category term="quant" scheme="https://rchardzhu.github.io/categories/quant/"/>
    
    <category term="python" scheme="https://rchardzhu.github.io/categories/python/"/>
    
    
    <category term="quant" scheme="https://rchardzhu.github.io/tags/quant/"/>
    
    <category term="python" scheme="https://rchardzhu.github.io/tags/python/"/>
    
    <category term="invest" scheme="https://rchardzhu.github.io/tags/invest/"/>
    
  </entry>
  
  <entry>
    <title>markdown实战笔记</title>
    <link href="https://rchardzhu.github.io/2022/02/03/markdown-practice-md/"/>
    <id>https://rchardzhu.github.io/2022/02/03/markdown-practice-md/</id>
    <published>2022-02-03T13:22:35.000Z</published>
    <updated>2022-02-03T13:45:17.434Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。Markdown 编写的文档后缀为 .md, .markdown。</p><h2 id="markdown语法"><a href="#markdown语法" class="headerlink" title="markdown语法"></a>markdown语法</h2><ul><li>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推</li><li><code>*斜体文本*，**粗体文本**， ***粗斜体文本***</code></li><li>一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西</li><li>文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~即可</li><li>下划线可以通过 HTML 的 <code>&lt;u&gt;&lt;/u&gt;</code> 标签来实现</li><li>换行： 使用html <code>&lt;br&gt;</code>标签</li><li>脚注是对文本的补充说明<code>说明文本[^要注明的文本]</code> 在文末加上<code>[^要注明的文本]: markdown说明</code></li><li>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要加一个空格，然后再填写内容； 有序列表使用数字并加上 . 号来表示</li><li>使用反斜杠转义特殊字符，如*号，可以使用<code>\*</code>来解决</li><li>区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号。区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推。如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进</li><li>函数或片段的代码可以用反引号`把它包起来，可以用 ``` 包裹一段代码，并指定一种语言</li><li>链接：<code>[链接名称](链接地址) or &lt;链接地址&gt;</code></li><li>图片：<code>![alt 属性文本](图片地址) or ![alt 属性文本](图片地址 &quot;可选标题&quot;)</code>，如果想指定图片宽度高度，需要使用html的<code>&lt;img&gt;</code>标签，如<code>&lt;img src=&quot;http://www.xxx.com/xxx.jpg&quot; width=&quot;50%&quot;&gt;</code> </li><li>表格：使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。-: 设置内容和标题栏居右对齐，:- 设置内容和标题栏居左对齐， :-: 设置内容和标题栏居中对齐<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |， </span><br></pre></td></tr></table></figure></li><li>任务列表：<code>- [ ] foo， - [x] bar</code></li><li>公式： 要显示α，在”\alpha” 前后分别加上$，<code>$\alpha$</code>，上标 <code>$a^b$</code>，下标<code>$a_b$</code>，分数<code>$\frac&#123;3+8a&#125;&#123;5b+6&#125;$</code>， 求和 <code>$\sum&#123;3x^n&#125;$</code> 。其他写法参考<a href="https://rpruim.github.io/s341/S19/from-class/MathinRmd.html">Mathematics in R Markdown</a></li></ul><h2 id="markdown编辑软件"><a href="#markdown编辑软件" class="headerlink" title="markdown编辑软件"></a>markdown编辑软件</h2><ul><li><a href="https://marktext.app/">marktext</a> – 从官网下载，或者使用<code>brew install --cask mark-text</code>安装， 具体见<a href="https://github.com/marktext/marktext/blob/develop/docs/i18n/zh_cn.md#readme">marktext中文说明</a></li><li>visual code插件之Markdown All in One： 包括快捷键、公式等功能</li><li>visual code插件之Markdown Preview Enhanced： 除了实时预览外，还包括了其他许多有用的功能，包括mermaid, PlantUML, pandoc, PDF导出等功能</li><li><a href="https://typora.io/">typora</a> –  从1.0.0开始收费</li></ul><h2 id="markdown文件导出为html、doc、epub、pdf格式"><a href="#markdown文件导出为html、doc、epub、pdf格式" class="headerlink" title="markdown文件导出为html、doc、epub、pdf格式"></a>markdown文件导出为html、doc、epub、pdf格式</h2><ol><li>安装pandoc，<code>brew install pandoc</code></li><li>将markdown转成html: <code>pandoc -f markdown -t html ./test.md</code> </li><li>将markdown转成doc：<code>pandoc -f markdown -t html ./test.md | pandoc -f html -t docx -o test.docx</code></li><li>将markdown转成PDF，需要安装<a href="https://www.latex-project.org/">latex</a>。只要安装basicTex就可以了，大概100M+,安装完后运行：<code>pandoc -f markdown_github test.md -o test.pdf --latex-engine=xelatex -V mainfont=&quot;SimSun&quot;</code> 这个表明使用的是GitHub风格markdown语法</li><li>将markdown转成epub： <code>pandoc -f markdown  ./test.md -o test.epub</code></li></ol><h2 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h2><p>我发文章的几个地方，欢迎大家在朋友圈等地方分享，多多交流。</p><ul><li>微信公众号：诸葛说talk</li><li>知乎：<a href="https://www.zhihu.com/people/richard-zhu/posts">https://www.zhihu.com/people/richard-zhu/posts</a></li><li>博客：<a href="https://rchardzhu.github.io/">https://rchardzhu.github.io/</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zh.wikipedia.org/wiki/Markdown">markdown wikipedia</a></li><li><a href="https://github.github.com/gfm/">GitHub Flavored Markdown Spec</a> – github风味markdown规范增加了表格、删除线、自动链接和任务列表功能</li><li><a href="https://pandoc.org/demos.html">pandoc demos</a></li><li><a href="https://geek-docs.com/markdown/markdown-tutorial/markdown-mathematical-formula.html">Markdown数学公式</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</summary>
      
    
    
    
    <category term="blog" scheme="https://rchardzhu.github.io/categories/blog/"/>
    
    <category term="tool" scheme="https://rchardzhu.github.io/categories/tool/"/>
    
    
    <category term="markdown" scheme="https://rchardzhu.github.io/tags/markdown/"/>
    
    <category term="blog" scheme="https://rchardzhu.github.io/tags/blog/"/>
    
    <category term="github" scheme="https://rchardzhu.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>python代码/编码规范--pep8和google的python代码规范</title>
    <link href="https://rchardzhu.github.io/2022/02/02/python-coding-style/"/>
    <id>https://rchardzhu.github.io/2022/02/02/python-coding-style/</id>
    <published>2022-02-02T15:45:28.000Z</published>
    <updated>2022-02-03T01:58:44.884Z</updated>
    
    <content type="html"><![CDATA[<p>当所有代码均保持一致的风格时，阅读别人的代码沟通成本最低，特别是在理解大型代码库时效率提升很大。python使用的比较多的代码规范包括2种，分别如下：</p><ul><li><a href="https://www.python.org/dev/peps/pep-0008/">pep8 python编码规范</a></li><li><a href="https://google.github.io/styleguide/pyguide.html">google python编码规范</a> </li></ul><p>pep8是python编码规范的事实标准，google python编码规范做了更多的说明，可以作为pep8的补充。这也意味着python社区开源贡献者基本都遵守pep8，但不一定遵守google的python编码规范。</p><h2 id="pep8的一些规则"><a href="#pep8的一些规则" class="headerlink" title="pep8的一些规则"></a>pep8的一些规则</h2><p>参考pep8的目录，摘取一些重要的规则，具体使用的时候可以通过工具来检测。</p><p>1.1 代码布局</p><ul><li>每个缩进级别使用4个空格；连续行使用垂直对齐或者使用悬挂式缩进(额外的4个空格缩进)</li><li>空格是首选的缩进方法</li><li>每行最多79个字符</li><li>二元运算符前后换行都允许，只要代码保持一致就行。对于新代码建议在二元运算符前进行换行</li><li>空白行：使用两个空白行分隔顶层函数和类定义；类方法定义使用一个空行分隔；使用额外的空白行来分隔相关逻辑功能</li><li>文件应该使用UTF-8编码, 且不应该有编码声明</li><li>导入多个库函数应该分开依次导入；导入总是放在文件的顶部，在任何模块注释和文档字符串之后，在模块全局变量和常量之前；导入应按以下顺序进行：标准库导入、有关的第三方库进口、本地应用程序/库特定的导入，每组导入直接用空行分隔；避免通配符导入（import *）</li></ul><p>1.2 字符串</p><ul><li>单引号字符串和双引号字符串相同，代码保持一致即可</li><li>对于三引号字符串，常用三个双引号作文档字符串，文档字符串常用在模块的开端用以说明模块的基本功能，或紧跟函数定义的后面用以说明函数的基本功能</li></ul><p>1.3 空格</p><ul><li>避免使用无关的空格，包括空格内、逗号分号前面等</li><li>避免在行末使用空格</li><li>二元运算符在两侧使用一个空格</li><li>当用于指示关键字参数或默认参数值时，不要在=符号周围使用空格</li></ul><p>1.4 使用尾部逗号(trailing commas)</p><ul><li>尾部逗号通常可选，除了用来说明是只有一个元素的元组tuple时</li><li>当参数、值等列表期望经常扩展时，通常是每个值一行，再加上一个尾部逗号</li></ul><p>1.5 注释</p><ul><li>代码更改时，相应的注释也要随之高优更改</li><li>注释应该是完整的语句，第一个单词应该大写，除非它是特定标识符</li><li>块注释：缩进到与该代码相同的级别。块注释的每一行都以＃和一个空格开始</li><li>行注释：对某一语句行进行注释，注释应该与语句至少隔开两个空格，用＃和一个空格开始</li><li>对于公共的modules, functions, classes, and methods，需要写文档字符串</li><li>注释应该是完整的语句，第一个单词应该大写，除非它是特定标识符 </li></ul><p>1.6 命名约定</p><ul><li>python命名规范有点混乱，很难完全保存一致。对于新模块和包，应该遵守这些新的约定，已存在的库内部一致性更重要</li><li>命名应该反应其用途而非实现</li><li>不要将字符’l’（小写字母l），’O’（大写字母o）或’I’（大写字母I）作为单个字符变量名称</li><li>模块名应该使用简短、全小写的名字</li><li>类的命名采用驼峰命名法，即每个单词的首字母大写</li><li>函数名称应该是小写的，为了提高可读性，必须使用由下划线分隔的单词</li></ul><h2 id="google-python编码规范的一些规则"><a href="#google-python编码规范的一些规则" class="headerlink" title="google python编码规范的一些规则"></a>google python编码规范的一些规则</h2><p>相比pep8，google编码规范对怎么写代码的细节要求更多。比如怎么使用异常，文档字符串怎么写，Todo注释的使用等。参考规范目录摘取一些重要的规则说明</p><p>2.1 背景</p><ul><li>可以使用yapf自动格式化工具来格式化代码 </li></ul><p>2.2 python语言规则</p><ul><li>使用google的pylintrc配置文件来允许pylint</li><li>只对包和模块使用import语句，不对单个类或函数使用import</li><li>使用绝对路径导入每个模块</li><li>可以使用异常但必须非常小心。不要使用assert语句来验证api的参数值；最小化try/except代码块</li><li>避免全局变量</li></ul><p>2.3 python风格规则</p><ul><li>不使用分号作为行尾，不使用分号将2个语句放到同一行</li><li>不要在return语句或条件语句使用括号，除非使用括号来表示连续行或元组</li><li>每行最长80个字符，每个缩进级别使用4个空格，空行、空格跟pep8基本一致</li><li>main文件使用#!/usr/bin/env python3 或#!/usr/bin/python3开头，绝大部分文件不需要使用#！开头</li><li>每个文件应该包含一个版权声明</li><li>使用 f-string，%操作符或者format函数来格式化字符串</li><li>使用TODO注释说明临时的、短期的解决方案</li></ul><p>2.4 保持一致性</p><h2 id="python编码规范检查工具"><a href="#python编码规范检查工具" class="headerlink" title="python编码规范检查工具"></a>python编码规范检查工具</h2><p>光有规范不行，需要有配套的检查工具，方便团队开发代码时统一遵守</p><p>比如我用pycharm来编写Python代码时，如果有出现不符合PEP 8规范的话，pycharm就会提示我，如图所示。<br><img src="https://pic2.zhimg.com/80/v2-3a4fb851d10c2e8036bb977c861d66d1_720w.jpg" alt="pycharm提示"></p><p>更多工具如下：</p><ul><li><a href="https://pypi.org/project/pycodestyle/">pycodestyle</a> – pycodestyle是一款简单的代码检查工具，之前名字叫pep8，为了减少混淆改名成pycodestyle</li><li><a href="https://pylint.org/">pylint</a> – pylint是代码检查工具，不能自动修改代码，有对于的配置文件，可以参考<a href="https://google.github.io/styleguide/pylintrc">google开源的pylintrc配置文件</a></li><li><a href="https://pypi.org/project/pyflakes/">PyFlakes</a> – 一个简单的python错误检查工具,通过解析源代码而不是import来检测不同的错误，通常只能检查出一些逻辑错误</li><li><a href="https://pypi.org/project/flake8/">flake8</a> – 针对PEPE8进行代码规范提示，是对PyFlakes，pycodestyle的封装</li><li><a href="https://github.com/hhatto/autopep8">autopep8</a> – autopep8是一款将python代码自动排版为PEP8风格的工具，它使用 pycodestyle来决定哪部分代码需要格式化</li><li><a href="https://github.com/google/yapf/">yapf</a>–yapf是google开源的一个用于格式化Python代码的工具，可以一键美化代码，支持两种规范：PEP8和Google Style</li></ul><h2 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h2><p>我发文章的几个地方，欢迎大家在朋友圈等地方分享，多多交流。</p><ul><li>微信公众号：诸葛说talk</li><li>知乎：<a href="https://www.zhihu.com/people/richard-zhu/posts">诸葛说</a></li><li>博客：<a href="https://rchardzhu.github.io/">https://rchardzhu.github.io/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当所有代码均保持一致的风格时，阅读别人的代码沟通成本最低，特别是在理解大型代码库时效率提升很大。python使用的比较多的代码规范包括2种，分别如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-000</summary>
      
    
    
    
    <category term="quant" scheme="https://rchardzhu.github.io/categories/quant/"/>
    
    <category term="python" scheme="https://rchardzhu.github.io/categories/python/"/>
    
    
    <category term="python" scheme="https://rchardzhu.github.io/tags/python/"/>
    
    <category term="google" scheme="https://rchardzhu.github.io/tags/google/"/>
    
    <category term="coding" scheme="https://rchardzhu.github.io/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>利用github搭建自己的免费博客站点</title>
    <link href="https://rchardzhu.github.io/2022/01/22/using-github-to-start-your-blog/"/>
    <id>https://rchardzhu.github.io/2022/01/22/using-github-to-start-your-blog/</id>
    <published>2022-01-22T05:43:46.000Z</published>
    <updated>2022-01-22T10:24:06.757Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎访问我的站点： <a href="https://rchardzhu.github.io/">https://rchardzhu.github.io/</a></p><h2 id="一、在github上创建一个代码库"><a href="#一、在github上创建一个代码库" class="headerlink" title="一、在github上创建一个代码库"></a>一、在github上创建一个代码库</h2><p>在github上创建一个代码库，名字为：xxx.github.io， xxx为你的github账号名</p><p>如我的代码库地址为：<a href="https://github.com/rchardzhu/rchardzhu.github.io">https://github.com/rchardzhu/rchardzhu.github.io</a></p><p>参考：<a href="https://docs.github.com/en/pages/quickstart">Quickstart for GitHub Pages - GitHub Docs</a></p><h2 id="二、安装nodejs和hexo"><a href="#二、安装nodejs和hexo" class="headerlink" title="二、安装nodejs和hexo"></a>二、安装nodejs和hexo</h2><p>由于github只支持静态网页，需要使用hexo。hexo是基于nodejs打造的一个博客框架，用于快速创建项目、页面、编译、部署 Hexo 博客。</p><ul><li>先安装nodejs</li><li><code>npm install hexo</code>， 然后把hexo的目录放到PATH目录下。或者使用-g 安装到全局目录，但需要管理员权限</li></ul><h2 id="三、运行hexo"><a href="#三、运行hexo" class="headerlink" title="三、运行hexo"></a>三、运行hexo</h2><ol><li><p>创建blog项目，<code>$hexo init blog</code><br>blog目录文件夹下就会出现 Hexo 的初始化文件，包括 themes、scaffolds、source 等文件夹</p></li><li><p>进入blog目录，生成静态文件：<code>$ cd blog &amp;&amp; hexo generate</code><br>可以看到输出结果里面包含了 js、css、font 等内容，并发现它们都在项目根目录下的 public 文件夹下面了</p></li><li><p>本地预览查看： <code>$hexo serve</code><br>可以看到一个默认的hello world页面。</p></li><li><p>部署到github： <code>$ hexo deploy</code><br>编辑_config.yml文件，编辑deploy部分，参考如下<img src="https://pic2.zhimg.com/80/v2-1578f3c362f0896c7dbe3b77e3cc94b1_720w.jpg" alt="图片"></p></li></ol><p>在新创建的blog目录下安装hexo-deployer-git，命令如下： <code>$npm install hexo-deployer-git --save</code></p><p>更多信息参考：<a href="https://hexo.io/zh-cn/docs/one-command-deployment.html">部署</a></p><p>如果出现如下错误：”ERROR Deployer not found: git”，表明hexo-deployer-git安装的目录不对，记住需要在新创建的目录下npm install。</p><h2 id="四、写博客"><a href="#四、写博客" class="headerlink" title="四、写博客"></a>四、写博客</h2><ol><li>新建文章 ： <code>$ hexo new &quot;about&quot;</code><br>创建的文章会出现在 source/_posts 文件夹下，是 MarkDown 格式。</li></ol><p>更多信息参考：<a href="https://hexo.io/zh-cn/docs/writing.html">写作</a></p><p>然后正常使用markdown格式去写文章就好了。</p><ol start="2"><li>生成静态文件并更新到github上即可<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$hexo clean</span><br><span class="line">$hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></li></ol><h2 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h2><ul><li><p><a href="https://zhuanlan.zhihu.com/p/454680697">如何更换博客主题</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/454705927">如何新增标签、分类、关于等页面</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/454840985">如何添加搜索功能?</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/454857343">如何添加留言板功能</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/454865095">本地运行和发布不一致问题解决</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/459178301">添加文章阅读量及网站访问信息</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;欢迎访问我的站点： &lt;a href=&quot;https://rchardzhu.github.io/&quot;&gt;https://rchardzhu.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、在github上创建一个代码库&quot;&gt;&lt;a href=&quot;#一、在github上创建一个</summary>
      
    
    
    
    <category term="blog" scheme="https://rchardzhu.github.io/categories/blog/"/>
    
    
    <category term="blog" scheme="https://rchardzhu.github.io/tags/blog/"/>
    
    <category term="github" scheme="https://rchardzhu.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>量化资源--awesome quant中文版发布</title>
    <link href="https://rchardzhu.github.io/2022/01/08/awesome-quant-cn/"/>
    <id>https://rchardzhu.github.io/2022/01/08/awesome-quant-cn/</id>
    <published>2022-01-07T16:35:30.000Z</published>
    <updated>2022-01-08T05:38:49.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="awesome-quant-cn"><a href="#awesome-quant-cn" class="headerlink" title="awesome-quant-cn"></a>awesome-quant-cn</h1><p><a href="https://github.com/rchardzhu/awesome-quant-cn">awesome quant中文版</a>，最近会更新比较频繁，欢迎关注github以及加入qq群～</p><h2 id="金融数据"><a href="#金融数据" class="headerlink" title="金融数据"></a>金融数据</h2><ul><li><a href="https://waditu.com/document/1?doc_id=131">tushare</a> – 分为tushare和tushare pro。tushare pro数据覆盖范围广，接口调用简单,响应快速，但获取次数较多时有积分限制。老版api有下线风险</li><li><a href="https://github.com/akfamily/akshare">akshare</a> – 基于 Python 的财经数据接口库, 目的是实现对股票、期货、期权、基金、外汇、债券、指数、加密货币等金融产品的基本面数据、实时和历史行情数据、衍生数据从数据采集、数据清洗到数据落地的一套工具</li><li><a href="https://github.com/ranaroussi/yfinance">yfinace</a> – yahoo财经</li><li><a href="https://www.joinquant.com/help/api/help#name:JQData">jqdatasdk</a> – 聚宽提供的本地量化金融数据服务</li><li><a href="https://doc.shinnytech.com/tqsdk/latest/intro.html">tqsdk</a> – TqSdk免费版本提供全部的期货、商品/金融期权和上证50、沪深300和中证500的实时行情，TqSdk专业版可提供A股股票的实时和历史行情</li><li><a href="https://github.com/Micro-sheep/efinance">efinance</a> – 个人打造的用于获取股票、基金、期货数据的免费开源 Python 库</li><li><a href="https://github.com/shidenggui/easyquotation">easyquotation</a> – 快速获取新浪/腾讯的全市场行情</li></ul><h2 id="回测引擎"><a href="#回测引擎" class="headerlink" title="回测引擎"></a>回测引擎</h2><ul><li><a href="https://github.com/quantopian/zipline">zipline</a> – Quantopian开源的本地量化回测平台，可以和pyfolio和alphalen无缝衔接</li><li><a href="https://github.com/ricequant/rqalpha">rqalpha</a> – Ricequant开源的本地量化回测平台，在 API 设计上和 Quantopian 保持一致，但License完全排除商业用途</li><li><a href="https://github.com/mementum/backtrader">backtrader</a> – 纯python实现的在线交易和回测平台</li><li><a href="https://github.com/zvtvz/zvt/blob/master/README-cn.md">zvt</a> – 包含可扩展的数据recorder，api，因子计算，选股，回测，交易,以及统一的可视化，抽象度较高</li><li><a href="https://github.com/pmorissette/bt">bt</a> – 基于ffn打造的python回测框架， 目标是充分利用python生态，不重复造轮子</li></ul><h2 id="风险分析"><a href="#风险分析" class="headerlink" title="风险分析"></a>风险分析</h2><ul><li><a href="https://github.com/quantopian/pyfolio">pyfolio</a> – Quantopian开发的用于金融投资组合性能和风险分析的Python库</li><li><a href="https://github.com/quantopian/empyrical">empyrical</a> – Quantopian开源的常见金融风险指标</li><li><a href="https://github.com/ranaroussi/quantstats">quantstats</a> – 更深层次的python量化分析和风险指标</li></ul><h2 id="实盘交易"><a href="#实盘交易" class="headerlink" title="实盘交易"></a>实盘交易</h2><ul><li><a href="https://github.com/vnpy/vnpy">vnpy</a> – 基于Python的开源量化交易系统开发框架</li><li><a href="https://openapi.futunn.com/futu-api-doc/intro/intro.html">Futu OpenAPI</a> – 功能主要有两部分：行情和交易。支持香港、美国、A 股市场的行情数据，涉及的品类包括股票、指数、期权、期货等；支持香港、美国、A 股、新加坡、日本 5 个市场的交易能力，涉及的品类包括股票、期权、期货等</li><li><a href="https://quant.itiger.com/openapi/py-docs/zh-cn/docs/intro/quickstart.html">tigeropen</a> – 老虎开放平台提供的直接管理交易、查看帐户信息、查询行情变动及交易支持功能</li></ul><h2 id="策略研究平台"><a href="#策略研究平台" class="headerlink" title="策略研究平台"></a>策略研究平台</h2><ul><li><a href="https://www.joinquant.com/">聚宽</a> – 量化平台，提供多种数据方便投资研究；提供多种的策略评价指标与评价维度；支持多种策略的编写、回测、模拟、实盘</li><li><a href="https://www.ricequant.com/">米筐</a> – 米筐科技专注于为用户提供快速便捷、功能强大的量化交易和分析工具。用户可以使用基于浏览器（网上回测平台）或本地化（RQAlpha 等项目）的米筐科技产品，随时、随地开发自己的交易策略，验证自己的投资思路</li><li><a href="https://uqer.datayes.com/">优矿</a> – 量化平台，使用通联书记，支持回测功能</li></ul><h2 id="量化书籍"><a href="#量化书籍" class="headerlink" title="量化书籍"></a>量化书籍</h2><ul><li><a href="https://book.douban.com/subject/2339892/">海龟交易法则</a> – 豆瓣评分8.5分。原版海龟首次揭密适用于任何市场的交易策略</li></ul><h2 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h2><ul><li><a href="https://github.com/wilsonfreitas/awesome-quant">awesome-quant</a> – 可以参考</li></ul><h2 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h2><p>欢迎加入qq群交流，qq群号：835894006</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;awesome-quant-cn&quot;&gt;&lt;a href=&quot;#awesome-quant-cn&quot; class=&quot;headerlink&quot; title=&quot;awesome-quant-cn&quot;&gt;&lt;/a&gt;awesome-quant-cn&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https</summary>
      
    
    
    
    <category term="quant" scheme="https://rchardzhu.github.io/categories/quant/"/>
    
    <category term="python" scheme="https://rchardzhu.github.io/categories/python/"/>
    
    
    <category term="quant" scheme="https://rchardzhu.github.io/tags/quant/"/>
    
    <category term="awesome" scheme="https://rchardzhu.github.io/tags/awesome/"/>
    
    <category term="python" scheme="https://rchardzhu.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>关于</title>
    <link href="https://rchardzhu.github.io/2022/01/03/about/"/>
    <id>https://rchardzhu.github.io/2022/01/03/about/</id>
    <published>2022-01-03T13:48:38.000Z</published>
    <updated>2022-02-01T13:16:43.609Z</updated>
    
    <content type="html"><![CDATA[<p>Richard Zhu</p><p>A coder from China, interested in quant, search engine, feed, ads</p><p>博客：<a href="https://rchardzhu.github.io/">https://rchardzhu.github.io</a></p><p>知乎：<a href="https://www.zhihu.com/people/richard-zhu">https://www.zhihu.com/people/richard-zhu</a></p><p>公众号: <img src="/images/wechat_channel.png" alt="诸葛说talk"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Richard Zhu&lt;/p&gt;
&lt;p&gt;A coder from China, interested in quant, search engine, feed, ads&lt;/p&gt;
&lt;p&gt;博客：&lt;a href=&quot;https://rchardzhu.github.io/&quot;&gt;htt</summary>
      
    
    
    
    
    <category term="about" scheme="https://rchardzhu.github.io/tags/about/"/>
    
  </entry>
  
</feed>
